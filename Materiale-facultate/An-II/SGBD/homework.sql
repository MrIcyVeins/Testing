-- Varianta 1

SUBPROGRAME!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
= functii   ( functions )     - CREATE OR REPLACE FUNCTION <NUME>
= proceduri ( procedures )    - CREATE OR REPLACE PROCEDURE <NUME>

OBIECTE!!!!!!!!! 
= CREATE OR REPLACE TYPE <NUME> AS OBJECT();

TRIGGERE !!!!!!!!!!!!!!!!!!!!!!!!!!
= CREATE OR REPLACE TRIGGER <NUME>

COLECTIE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
= VARRAY - CREATE TYPE <NUME> AS VARRAY(dimensiune) OF NUMBER
= NESTED TABLE - CREATE TYPE <NUME> AS TABLE OF VARCHAR2(50);

În SQL poți folosi VARRAY și Nested Table.
În PL/SQL poți folosi și Associative Array.


EXEMPLU Procedura

    CREATE OR REPLACE PROCEDURE salut_procedura (p_nume IN VARCHAR2) IS
    BEGIN
       DBMS_OUTPUT.PUT_LINE('Salut, ' || p_nume || '!');
    END;
    
    -- apelare
    BEGIN
       salut_procedura('Andrei');
    END;

EXEMPLU FUNCTIE 

    CREATE OR REPLACE FUNCTION calculeaza_tva (p_valoare IN NUMBER)
    RETURN NUMBER IS
       v_tva NUMBER;
    BEGIN
       v_tva := p_valoare * 0.19; -- 19% TVA
       RETURN v_tva;
    END;
    
    BEGIN
    DBMS_OUTPUT.PUT_LINE('TVA: ' || calculeaza_tva(100));
    END;

EXEMPLU TRIGGER


select * from pacienti;

SET SERVEROUTPUT ON;
SAVEPOINT test;
ROLLBACK TO SAVEPOINT test;

-- 1) Funcții (roluri)
CREATE TABLE functii (
  functie_id   NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume_functie VARCHAR2(50) NOT NULL,
  CONSTRAINT pk_functii PRIMARY KEY (functie_id),
  CONSTRAINT uq_functii UNIQUE (nume_functie)
);

-- 2) Angajați
CREATE TABLE angajati (
  angajat_id  NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume        VARCHAR2(50) NOT NULL,
  prenume     VARCHAR2(50) NOT NULL,
  functie_id  NUMBER NOT NULL,
  CONSTRAINT pk_angajati PRIMARY KEY (angajat_id),
  CONSTRAINT fk_angajati_functii FOREIGN KEY (functie_id)
    REFERENCES functii(functie_id)
);

-- 3) Pacienți
CREATE TABLE pacienti (
  pacient_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume       VARCHAR2(50) NOT NULL,
  prenume    VARCHAR2(50) NOT NULL,
  gen        CHAR(1) NOT NULL,
  CONSTRAINT pk_pacienti PRIMARY KEY (pacient_id),
  CONSTRAINT ck_gen CHECK (gen IN ('F','M'))
);

-- 4) Îngrijiri (relație M:N între angajat și pacient)
CREATE TABLE ingrijiri (
  ingrijire_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  angajat_id   NUMBER NOT NULL,
  pacient_id   NUMBER NOT NULL,
  data_ingrijire DATE NOT NULL,
  CONSTRAINT pk_ingrijiri PRIMARY KEY (ingrijire_id),
  CONSTRAINT fk_ingrijiri_ang FOREIGN KEY (angajat_id) REFERENCES angajati(angajat_id),
  CONSTRAINT fk_ingrijiri_pac FOREIGN KEY (pacient_id) REFERENCES pacienti(pacient_id)
);
-- Funcții
INSERT INTO functii (nume_functie) VALUES ('Medic');
INSERT INTO functii (nume_functie) VALUES ('Asistent');
INSERT INTO functii (nume_functie) VALUES ('Fizioterapeut');

-- Angajați
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Ionescu',  'Ana',   2); -- Asistent
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Popescu',  'Mihai', 1); -- Medic
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Georgescu','Elena', 2); -- Asistent
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Matei',    'Radu',  3); -- Fizioterapeut
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Stan',     'Ioana', 1); -- Medic

-- Pacienți
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Dumitru','Maria','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Enache','Andrei','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Tudor','Irina','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Cristea','Vlad','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Nistor','Oana','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Neagu','Paul','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Gavrila','Bianca','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Ilie','Sorin','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Petrescu','Anca','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Moldovan','Dragos','M');

-- Îngrijiri (mapare angajat–pacient, unele repetate)
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 1, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 2, DATE '2025-05-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 3, DATE '2025-05-12');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 4, DATE '2025-05-13');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 1, DATE '2025-05-20');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 5, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 6, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 7, DATE '2025-05-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 8, DATE '2025-05-12');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 6, DATE '2025-05-20');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3, 1, DATE '2025-06-01');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3, 9, DATE '2025-06-02');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3,10, DATE '2025-06-03');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 2, DATE '2025-06-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 3, DATE '2025-06-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 4, DATE '2025-06-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 7, DATE '2025-06-12');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 5, DATE '2025-06-15');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 8, DATE '2025-06-16');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 9, DATE '2025-06-17');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5,10, DATE '2025-06-18');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 9, DATE '2025-06-25');

COMMIT;

SELECT * FROM pacienti;
SELECT * FROM angajati;
SELECT * FROM functii;
SELECT * FROM ingrijiri;

/*

1. Scrieti un subprogram care returneaza o evidenta cu privire la numarul de pacienti, de 
fiecare gen, pe care i-a ingrijit fiecare angajat. Subprogramul va returna o singura 
vaiabila de tiplu lista de obiecte( pentru fiecare angajat se returneaza codul numele 
functiei detinute, numarul de pacienti de gen feminin, respectiv masculin ingrijiti).

- subprogram ( procedure sau function )
- returneaza nr_pacienti, de fiecare gen < pe care i-a ingrijit fiecare angajat
- returneaza o singura variabila - de tip lista de obiecte  ( type .. as OBJECT ; type .. as TABLE OF .. ) 
- pentru fiecare angajat - se returneaza cod,nume_functie,numar_pacienti_feminin/masculin

*/

SET SERVEROUTPUT ON;
SAVEPOINT test;

DESCRIBE angajati;

-- Obiectul care descrie evidența pentru un angajat
CREATE OR REPLACE TYPE obiect_evidenta AS OBJECT (
  angajat_id   NUMBER,
  nume_complet VARCHAR2(120),
  functie      VARCHAR2(50),
  nr_femei     NUMBER,
  nr_barbati   NUMBER
);

-- Lista (nested table) de astfel de obiecte
CREATE OR REPLACE TYPE tabel AS TABLE OF obiect_evidenta;

-- Functia
CREATE OR REPLACE FUNCTION functie_evidenta
  RETURN tabel
IS
  l_tab tabel;
BEGIN
  SELECT obiect_evidenta(
           a.angajat_id,
           a.nume || ' ' || a.prenume,
           f.nume_functie,
           /* nr pacienți F distincti */
           COUNT(DISTINCT CASE WHEN p.gen = 'F' THEN p.pacient_id END),
           /* nr pacienți M distincti */
           COUNT(DISTINCT CASE WHEN p.gen = 'M' THEN p.pacient_id END)
         )
  BULK COLLECT INTO l_tab
  FROM angajati a
  JOIN functii f         ON f.functie_id  = a.functie_id
  LEFT JOIN ingrijiri i  ON i.angajat_id  = a.angajat_id
  LEFT JOIN pacienti p   ON p.pacient_id  = i.pacient_id
  GROUP BY a.angajat_id, a.nume, a.prenume, f.nume_functie
  ORDER BY a.angajat_id;

  RETURN l_tab;
END;

-- apelam functia
SELECT *
FROM TABLE(functie_evidenta());


SELECT * FROM specializari;

/* 

2. Trigger care la stergerea unui angajat care este manager de specializare, pune in locul 
acestuia angajatul care a avut cei mai multi pacienti ( si codul cel mai mic daca sunt 2 cu 
aceasta proprietate ) 

-- trigger > la stergerea unui angajat - where spec=manager > angajat where nr_pacienti max top FETCH FIRST 2 ROWS WITH TIES; 

3. Subprogram care primeste ca parametru un cod de functie si returneaza prin intermediul 
unui cursor lista odronata descrescator in functie de salariu, respectiv de cod a 
angajatilor care nu au tratat pacienti si au functia transmisa. 

- subprogram ( functie/procedura ) < primeste cod_functie 
> returneaza prin cursor lista ordonata descrescator in functie de salariu / cod care nu au tratat pacienti si au functia transmisa 

*/
SELECT * FROM pacienti;
SELECT * FROM angajati;

-- subprogram ( procedura ) < primeste cod_functie (p_functie_id IN ... )
CREATE OR REPLACE PROCEDURE p_procedura (p_functie_id IN angajati.functie_id%TYPE)
IS
    -- prin intermediul unui cursor
    CURSOR c IS
        SELECT a.angajat_id,
               a.nume,
               a.prenume,
               a.salariu
        FROM angajati a
        WHERE a.functie_id = p_functie_id
            AND NOT EXISTS ( SELECT 1 
                             FROM ingrijiri i
                             WHERE i.angajat_id = a.angajat_id)
        ORDER BY a.salariu DESC NULLS LAST,
                 a.angajat_id DESC;
BEGIN
    FOR rec IN c LOOP
        DBMS_OUTPUT.PUT_LINE('ID=' || rec.angajat_id || ', ' || rec.nume || ' ' || rec.prenume || ', Salariu= ' || rec.salariu);
    END LOOP;
END;

EXEC p_procedura(1);


-- Varianta 2
/*
AGENTIE_IMOBILIARA ( id_agentie, denumire, clasificare ) 
TRANZACTIONEAZA(cod_agentie, cod_imobil, data_tranzactiei, tip, valoare_comision, pret)  - unde tip inseamna vanzare/inchiriere  
IMOBIL(id_imobil, adresa, cod_proprietar, tip) unde tip inseamna casa, teren sau apartament 
PROPRIETAR(id_proprietar, nume) 


1. Adaugati o coloana de tip colectie la AGENTIE_IMOBILIARA care sa contina numarul de 
tranzactii de tip vanzare si numarul de inchirieri efectuate de 
fiecare agentie. Presupunand ca acesteau au fost actualizate, modificati clasificarea fiecarei 
agentii in functie de numarul de preponderent in 'rent', daca 
numarul de inchirieri efectuate este mai mare, sau in 'sales' in caz contrar.
*/
SELECT * FROM AGENTIE_IMOBILIARA;
DESC AGENTIE_IMOBILIARA;

-- creaza tabele
CREATE TABLE agentie_imobiliara ( id_agentie NUMBER, denumire VARCHAR(50), clasificare VARCHAR(20));
CREATE TABLE tranzactioneaza ( cod_agentie NUMBER, cod_imobil NUMBER, data_tranzactiei DATE, tip VARCHAR(20), valoare_comision NUMBER, pret NUMBER);
CREATE TABLE imobil (id_imobil NUMBER, adresa VARCHAR(100), cod_proprietar NUMBER, tip VARCHAR(15));
CREATE TABLE proprietar (id_proprietar NUMBER, nume VARCHAR(50));

-- insereaza in tabele
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 1, 'Agentie 1', 'ceva' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 2, 'Agentie 2', 'altceva' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 3, 'Agentie 3', 'zzz' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 4, 'Agentie 4', 'vvv' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 5, 'Agentie 5', 'ccc' );

SELECT * FROM agentie_imobiliara;
SELECT * FROM tranzactioneaza;

DESC agentie_imobiliara;
-- colectie = varray
CREATE OR REPLACE TYPE v_colectie AS VARRAY(2) OF NUMBER;
ALTER TABLE AGENTIE_IMOBILIARA ADD ( tranz_stat v_colectie );

-- populeaza tranz_stat ( care sa contina din cerinta )
UPDATE AGENTIE_IMOBILIARA a
SET tranz_stat = v_colectie(NVL ((SELECT COUNT(*) FROM tranzactioneaza t WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale'), 0 ),
    NVL((SELECT COUNT(*) FROM tranzactioneaza t WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent'), 0)
);

UPDATE agentie_imobiliara a
SET clasificare =
  CASE
    WHEN (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent')
       > (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale')
      THEN 'rent'
    WHEN (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale')
       > (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent')
      THEN 'sales'
    ELSE 'none'  
  END;
  
/* 2.
 Creati un subprogram pentru care ii transmiteti un an transmis ca parametru, afisati pentru 
fiecare agentie : denumirea ei, adresa tuturor imobilelor pe care 
le-a tranzactionat si totalul care l-a obtinut din acestea. 
*/

SELECT * FROM TRANZACTIONEAZA;
SELECT * FROM IMOBIL;
DESCRIBE imobil;
DESCRIBE agentie_imobiliara;

CREATE OR REPLACE PROCEDURE p_raport_agentii_pe_an (p_an IN NUMBER)
IS
BEGIN
  FOR r IN (
    SELECT a.denumire,
           i.adresa,
           SUM(t.valoare_comision) OVER (PARTITION BY a.id_agentie) AS total_obtinut
    FROM agentie_imobiliara a
    JOIN tranzactioneaza t ON t.cod_agentie = a.id_agentie
    JOIN imobil          i ON i.id_imobil   = t.cod_imobil
    WHERE EXTRACT(YEAR FROM t.data_tranzactiei) = p_an
    ORDER BY a.denumire, i.adresa
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('Agentie: ' || r.denumire ||
                         ', Imobil: ' || r.adresa ||
                         ', Total: ' || r.total_obtinut);
  END LOOP;
END;

EXEC p_raport_agentii_pe_an(2024);

/*
5. Creati un subprogram care pentru un nume de proprietar dat ca parametru, intoarce numarul 
de apartamente care acesta le-a tranzactionat cu firmele care au cele mai 
multe de tranzactii incheiate. Tratati exceptiile ce pot aparea.
*/

SELECT * FROM proprietar;
SELECT * FROM imobil;
SELECT * FROM tranzactioneaza;

CREATE OR REPLACE function f_subprogram (p_nume IN proprietar.nume%TYPE)
 RETURN NUMBER
IS
    v_prop_id proprietar.id_proprietar%TYPE;
    v_max_cnt NUMBER;
    V_nr_ap NUMBER := 0;
BEGIN
    -- identifica proprietarul
    SELECT id_proprietar
        INTO v_prop_id
        FROM proprietar
    WHERE nume = p_nume;
    
    -- numarul maxim de tranzactii pe agentie
    SELECT MAX(cnt)
        INTO v_max_cnt
        FROM ( 
            SELECT cod_agentie, COUNT(*) as cnt
            FROM tranzactioneaza
            GROUP BY cod_agentie
        );
    IF v_max_cnt IS NULL THEN
        RETURN 0;
    END IF;

    -- numar de apartamente distinct tranzactionate
    SELECT COUNT(DISTINCT t.cod_imobil)
        INTO v_nr_ap
        FROM tranzactioneaza t
        JOIN imobil i ON i.id_imobil = t.cod_imobil
    WHERE i.cod_proprietar = v_prop_id
        AND i.tip = 'apartament'
        AND t.cod_agentie IN (
            SELECT cod_agentie
            FROM ( 
                SELECT cod_agentie, COUNT(*) AS cnt
                FROM tranzactioneaza
                GROUP BY cod_agentie
            )
            WHERE cnt = v_max_cnt
        );
    RETURN v_nr_ap;
END;
    
SELECT f_subprogram('Stan Elena') AS nr_apartamente FROM dual;


SELECT 
    count(*) cod_imobil,
    p.nume,
    t.cod_agentie
FROM imobil i
JOIN proprietar p ON p.id_proprietar = i.cod_proprietar
JOIN tranzactioneaza t ON t.cod_imobil = i.id_imobil
--WHERE p.id_proprietar = 3
GROUP BY t.cod_agentie, p.nume

/*
Varianta 3 
Schemele relaţionale ale modelului folosit sunt:   
PREZENTARE (cod_pr, data, oras, nume)   
SPONSOR (cod_sponsor, nume, info ,tara_origine)   
SUSTINE (cod_pr, cod_sp, suma)   
VESTIMENTATIE(cod_vestimentatie, denumire, valoare, cod_prezentare)  

Exerciţii:  
1. Adăugaţi constrângerea de cheie externă dintre tabelele PREZENTARE şi VESTIMENTATIE. 
Implementaţi comportamentul ON DELETE CASCADE cu ajutorul unui trigger. Testaţi trigger-ul. 
(3p)  
2. Să se creeze un subprogram prin care se obţine media valorilor oferite de un sponsor al cărui 
cod este introdus ca parametru, pentru prezentările în care au existat minim x vestimentatii. 
Parametrul x va avea valoarea implicita  
3. Să se apeleze subprogramul. (3p) 3. Să se creeze un trigger prin care la inserarea unei noi 
vestimentații pentru o prezentare, suma valorilor vestimentațiilor rămâne mai mică decât suma 
sponsorizărilor. Altfel, apare o excepție. (3p) 

PREZENTARE (cod_pr, data, oras, nume)   
SPONSOR (cod_sponsor, nume, info ,tara_origine)   
SUSTINE (cod_pr, cod_sp, suma)   
VESTIMENTATIE(cod_vestimentatie, denumire, valoare, cod_prezentare)
*/

-- 1. constraint

ALTER TABLE VESTIMENTATIE
  ADD CONSTRAINT fk_vest_prez
  FOREIGN KEY (cod_prezentare)
  REFERENCES PREZENTARE(cod_pr);

CREATE OR REPLACE TRIGGER trg_prezentare_del_cascade
BEFORE DELETE ON PREZENTARE
FOR EACH ROW
BEGIN
  DELETE FROM VESTIMENTATIE
  WHERE cod_prezentare = :OLD.cod_pr;
END;


