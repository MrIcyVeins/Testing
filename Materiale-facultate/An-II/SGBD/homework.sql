-- Varianta 1

SUBPROGRAME!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
= functii   ( functions )     - CREATE OR REPLACE FUNCTION <NUME>
= proceduri ( procedures )    - CREATE OR REPLACE PROCEDURE <NUME>

OBIECTE!!!!!!!!! 
= CREATE OR REPLACE TYPE <NUME> AS OBJECT();

TRIGGERE !!!!!!!!!!!!!!!!!!!!!!!!!!
= CREATE OR REPLACE TRIGGER <NUME>

COLECTIE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
= VARRAY - CREATE TYPE <NUME> AS VARRAY(dimensiune) OF NUMBER
= NESTED TABLE - CREATE TYPE <NUME> AS TABLE OF VARCHAR2(50);

În SQL poți folosi VARRAY și Nested Table.
În PL/SQL poți folosi și Associative Array.


EXEMPLU Procedura

    CREATE OR REPLACE PROCEDURE salut_procedura (p_nume IN VARCHAR2) IS
    BEGIN
       DBMS_OUTPUT.PUT_LINE('Salut, ' || p_nume || '!');
    END;
    
    -- apelare
    BEGIN
       salut_procedura('Andrei');
    END;

EXEMPLU FUNCTIE 

    CREATE OR REPLACE FUNCTION calculeaza_tva (p_valoare IN NUMBER)
    RETURN NUMBER IS
       v_tva NUMBER;
    BEGIN
       v_tva := p_valoare * 0.19; -- 19% TVA
       RETURN v_tva;
    END;
    
    BEGIN
    DBMS_OUTPUT.PUT_LINE('TVA: ' || calculeaza_tva(100));
    END;

EXEMPLU TRIGGER


select * from pacienti;

SET SERVEROUTPUT ON;
SAVEPOINT test;
ROLLBACK TO SAVEPOINT test;

-- 1) Funcții (roluri)
CREATE TABLE functii (
  functie_id   NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume_functie VARCHAR2(50) NOT NULL,
  CONSTRAINT pk_functii PRIMARY KEY (functie_id),
  CONSTRAINT uq_functii UNIQUE (nume_functie)
);

-- 2) Angajați
CREATE TABLE angajati (
  angajat_id  NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume        VARCHAR2(50) NOT NULL,
  prenume     VARCHAR2(50) NOT NULL,
  functie_id  NUMBER NOT NULL,
  CONSTRAINT pk_angajati PRIMARY KEY (angajat_id),
  CONSTRAINT fk_angajati_functii FOREIGN KEY (functie_id)
    REFERENCES functii(functie_id)
);

-- 3) Pacienți
CREATE TABLE pacienti (
  pacient_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume       VARCHAR2(50) NOT NULL,
  prenume    VARCHAR2(50) NOT NULL,
  gen        CHAR(1) NOT NULL,
  CONSTRAINT pk_pacienti PRIMARY KEY (pacient_id),
  CONSTRAINT ck_gen CHECK (gen IN ('F','M'))
);

-- 4) Îngrijiri (relație M:N între angajat și pacient)
CREATE TABLE ingrijiri (
  ingrijire_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  angajat_id   NUMBER NOT NULL,
  pacient_id   NUMBER NOT NULL,
  data_ingrijire DATE NOT NULL,
  CONSTRAINT pk_ingrijiri PRIMARY KEY (ingrijire_id),
  CONSTRAINT fk_ingrijiri_ang FOREIGN KEY (angajat_id) REFERENCES angajati(angajat_id),
  CONSTRAINT fk_ingrijiri_pac FOREIGN KEY (pacient_id) REFERENCES pacienti(pacient_id)
);
-- Funcții
INSERT INTO functii (nume_functie) VALUES ('Medic');
INSERT INTO functii (nume_functie) VALUES ('Asistent');
INSERT INTO functii (nume_functie) VALUES ('Fizioterapeut');

-- Angajați
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Ionescu',  'Ana',   2); -- Asistent
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Popescu',  'Mihai', 1); -- Medic
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Georgescu','Elena', 2); -- Asistent
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Matei',    'Radu',  3); -- Fizioterapeut
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Stan',     'Ioana', 1); -- Medic

-- Pacienți
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Dumitru','Maria','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Enache','Andrei','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Tudor','Irina','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Cristea','Vlad','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Nistor','Oana','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Neagu','Paul','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Gavrila','Bianca','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Ilie','Sorin','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Petrescu','Anca','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Moldovan','Dragos','M');

-- Îngrijiri (mapare angajat–pacient, unele repetate)
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 1, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 2, DATE '2025-05-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 3, DATE '2025-05-12');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 4, DATE '2025-05-13');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 1, DATE '2025-05-20');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 5, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 6, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 7, DATE '2025-05-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 8, DATE '2025-05-12');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 6, DATE '2025-05-20');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3, 1, DATE '2025-06-01');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3, 9, DATE '2025-06-02');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3,10, DATE '2025-06-03');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 2, DATE '2025-06-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 3, DATE '2025-06-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 4, DATE '2025-06-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 7, DATE '2025-06-12');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 5, DATE '2025-06-15');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 8, DATE '2025-06-16');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 9, DATE '2025-06-17');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5,10, DATE '2025-06-18');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 9, DATE '2025-06-25');

COMMIT;

SELECT * FROM pacienti;
SELECT * FROM angajati;
SELECT * FROM functii;
SELECT * FROM ingrijiri;

/*

1. Scrieti un subprogram care returneaza o evidenta cu privire la numarul de pacienti, de 
fiecare gen, pe care i-a ingrijit fiecare angajat. Subprogramul va returna o singura 
vaiabila de tiplu lista de obiecte( pentru fiecare angajat se returneaza codul numele 
functiei detinute, numarul de pacienti de gen feminin, respectiv masculin ingrijiti).

- subprogram ( procedure sau function )
- returneaza nr_pacienti, de fiecare gen < pe care i-a ingrijit fiecare angajat
- returneaza o singura variabila - de tip lista de obiecte  ( type .. as OBJECT ; type .. as TABLE OF .. ) 
- pentru fiecare angajat - se returneaza cod,nume_functie,numar_pacienti_feminin/masculin

*/

SET SERVEROUTPUT ON;
SAVEPOINT test;

DESCRIBE angajati;

-- Obiectul care descrie evidența pentru un angajat
CREATE OR REPLACE TYPE obiect_evidenta AS OBJECT (
  angajat_id   NUMBER,
  nume_complet VARCHAR2(120),
  functie      VARCHAR2(50),
  nr_femei     NUMBER,
  nr_barbati   NUMBER
);

-- Lista (nested table) de astfel de obiecte
CREATE OR REPLACE TYPE tabel AS TABLE OF obiect_evidenta;

-- Functia
CREATE OR REPLACE FUNCTION functie_evidenta
  RETURN tabel
IS
  l_tab tabel;
BEGIN
  SELECT obiect_evidenta(
           a.angajat_id,
           a.nume || ' ' || a.prenume,
           f.nume_functie,
           /* nr pacienți F distincti */
           COUNT(DISTINCT CASE WHEN p.gen = 'F' THEN p.pacient_id END),
           /* nr pacienți M distincti */
           COUNT(DISTINCT CASE WHEN p.gen = 'M' THEN p.pacient_id END)
         )
  BULK COLLECT INTO l_tab
  FROM angajati a
  JOIN functii f         ON f.functie_id  = a.functie_id
  LEFT JOIN ingrijiri i  ON i.angajat_id  = a.angajat_id
  LEFT JOIN pacienti p   ON p.pacient_id  = i.pacient_id
  GROUP BY a.angajat_id, a.nume, a.prenume, f.nume_functie
  ORDER BY a.angajat_id;

  RETURN l_tab;
END;

-- apelam functia
SELECT *
FROM TABLE(functie_evidenta());


SELECT * FROM specializari;

/* 

2. Trigger care la stergerea unui angajat care este manager de specializare, pune in locul 
acestuia angajatul care a avut cei mai multi pacienti ( si codul cel mai mic daca sunt 2 cu 
aceasta proprietate ) 

-- trigger > la stergerea unui angajat - where spec=manager > angajat where nr_pacienti max top FETCH FIRST 2 ROWS WITH TIES; 

3. Subprogram care primeste ca parametru un cod de functie si returneaza prin intermediul 
unui cursor lista odronata descrescator in functie de salariu, respectiv de cod a 
angajatilor care nu au tratat pacienti si au functia transmisa. 

- subprogram ( functie/procedura ) < primeste cod_functie 
> returneaza prin cursor lista ordonata descrescator in functie de salariu / cod care nu au tratat pacienti si au functia transmisa 

*/
SELECT * FROM pacienti;
SELECT * FROM angajati;

-- subprogram ( procedura ) < primeste cod_functie (p_functie_id IN ... )
CREATE OR REPLACE PROCEDURE p_procedura (p_functie_id IN angajati.functie_id%TYPE)
IS
    -- prin intermediul unui cursor
    CURSOR c IS
        SELECT a.angajat_id,
               a.nume,
               a.prenume,
               a.salariu
        FROM angajati a
        WHERE a.functie_id = p_functie_id
            AND NOT EXISTS ( SELECT 1 
                             FROM ingrijiri i
                             WHERE i.angajat_id = a.angajat_id)
        ORDER BY a.salariu DESC NULLS LAST,
                 a.angajat_id DESC;
BEGIN
    FOR rec IN c LOOP
        DBMS_OUTPUT.PUT_LINE('ID=' || rec.angajat_id || ', ' || rec.nume || ' ' || rec.prenume || ', Salariu= ' || rec.salariu);
    END LOOP;
END;

EXEC p_procedura(1);


-- Varianta 2
/*
AGENTIE_IMOBILIARA ( id_agentie, denumire, clasificare ) 
TRANZACTIONEAZA(cod_agentie, cod_imobil, data_tranzactiei, tip, valoare_comision, pret)  - unde tip inseamna vanzare/inchiriere  
IMOBIL(id_imobil, adresa, cod_proprietar, tip) unde tip inseamna casa, teren sau apartament 
PROPRIETAR(id_proprietar, nume) 


1. Adaugati o coloana de tip colectie la AGENTIE_IMOBILIARA care sa contina numarul de 
tranzactii de tip vanzare si numarul de inchirieri efectuate de 
fiecare agentie. Presupunand ca acesteau au fost actualizate, modificati clasificarea fiecarei 
agentii in functie de numarul de preponderent in 'rent', daca 
numarul de inchirieri efectuate este mai mare, sau in 'sales' in caz contrar.
*/
SELECT * FROM AGENTIE_IMOBILIARA;
DESC AGENTIE_IMOBILIARA;

-- creaza tabele
CREATE TABLE agentie_imobiliara ( id_agentie NUMBER, denumire VARCHAR(50), clasificare VARCHAR(20));
CREATE TABLE tranzactioneaza ( cod_agentie NUMBER, cod_imobil NUMBER, data_tranzactiei DATE, tip VARCHAR(20), valoare_comision NUMBER, pret NUMBER);
CREATE TABLE imobil (id_imobil NUMBER, adresa VARCHAR(100), cod_proprietar NUMBER, tip VARCHAR(15));
CREATE TABLE proprietar (id_proprietar NUMBER, nume VARCHAR(50));

-- insereaza in tabele
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 1, 'Agentie 1', 'ceva' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 2, 'Agentie 2', 'altceva' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 3, 'Agentie 3', 'zzz' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 4, 'Agentie 4', 'vvv' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 5, 'Agentie 5', 'ccc' );

SELECT * FROM agentie_imobiliara;
SELECT * FROM tranzactioneaza;

DESC agentie_imobiliara;
-- colectie = varray
CREATE OR REPLACE TYPE v_colectie AS VARRAY(2) OF NUMBER;
ALTER TABLE AGENTIE_IMOBILIARA ADD ( tranz_stat v_colectie );

-- populeaza tranz_stat ( care sa contina din cerinta )
UPDATE AGENTIE_IMOBILIARA a
SET tranz_stat = v_colectie(NVL ((SELECT COUNT(*) FROM tranzactioneaza t WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale'), 0 ),
    NVL((SELECT COUNT(*) FROM tranzactioneaza t WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent'), 0)
);

UPDATE agentie_imobiliara a
SET clasificare =
  CASE
    WHEN (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent')
       > (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale')
      THEN 'rent'
    WHEN (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale')
       > (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent')
      THEN 'sales'
    ELSE 'none'  
  END;
  
/* 2.
 Creati un subprogram pentru care ii transmiteti un an transmis ca parametru, afisati pentru 
fiecare agentie : denumirea ei, adresa tuturor imobilelor pe care 
le-a tranzactionat si totalul care l-a obtinut din acestea. 
*/

SELECT * FROM TRANZACTIONEAZA;
SELECT * FROM IMOBIL;
DESCRIBE imobil;
DESCRIBE agentie_imobiliara;

CREATE OR REPLACE PROCEDURE p_raport_agentii_pe_an (p_an IN NUMBER)
IS
BEGIN
  FOR r IN (
    SELECT a.denumire,
           i.adresa,
           SUM(t.valoare_comision) OVER (PARTITION BY a.id_agentie) AS total_obtinut
    FROM agentie_imobiliara a
    JOIN tranzactioneaza t ON t.cod_agentie = a.id_agentie
    JOIN imobil          i ON i.id_imobil   = t.cod_imobil
    WHERE EXTRACT(YEAR FROM t.data_tranzactiei) = p_an
    ORDER BY a.denumire, i.adresa
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('Agentie: ' || r.denumire ||
                         ', Imobil: ' || r.adresa ||
                         ', Total: ' || r.total_obtinut);
  END LOOP;
END;

EXEC p_raport_agentii_pe_an(2024);

/*
5. Creati un subprogram care pentru un nume de proprietar dat ca parametru, intoarce numarul 
de apartamente care acesta le-a tranzactionat cu firmele care au cele mai 
multe de tranzactii incheiate. Tratati exceptiile ce pot aparea.
*/

SELECT * FROM proprietar;
SELECT * FROM imobil;
SELECT * FROM tranzactioneaza;

CREATE OR REPLACE function f_subprogram (p_nume IN proprietar.nume%TYPE)
 RETURN NUMBER
IS
    v_prop_id proprietar.id_proprietar%TYPE;
    v_max_cnt NUMBER;
    V_nr_ap NUMBER := 0;
BEGIN
    -- identifica proprietarul
    SELECT id_proprietar
        INTO v_prop_id
        FROM proprietar
    WHERE nume = p_nume;
    
    -- numarul maxim de tranzactii pe agentie
    SELECT MAX(cnt)
        INTO v_max_cnt
        FROM ( 
            SELECT cod_agentie, COUNT(*) as cnt
            FROM tranzactioneaza
            GROUP BY cod_agentie
        );
    IF v_max_cnt IS NULL THEN
        RETURN 0;
    END IF;

    -- numar de apartamente distinct tranzactionate
    SELECT COUNT(DISTINCT t.cod_imobil)
        INTO v_nr_ap
        FROM tranzactioneaza t
        JOIN imobil i ON i.id_imobil = t.cod_imobil
    WHERE i.cod_proprietar = v_prop_id
        AND i.tip = 'apartament'
        AND t.cod_agentie IN (
            SELECT cod_agentie
            FROM ( 
                SELECT cod_agentie, COUNT(*) AS cnt
                FROM tranzactioneaza
                GROUP BY cod_agentie
            )
            WHERE cnt = v_max_cnt
        );
    RETURN v_nr_ap;
END;
    
SELECT f_subprogram('Stan Elena') AS nr_apartamente FROM dual;


SELECT 
    count(*) cod_imobil,
    p.nume,
    t.cod_agentie
FROM imobil i
JOIN proprietar p ON p.id_proprietar = i.cod_proprietar
JOIN tranzactioneaza t ON t.cod_imobil = i.id_imobil
--WHERE p.id_proprietar = 3
GROUP BY t.cod_agentie, p.nume

/*
Varianta 3 
Schemele relaţionale ale modelului folosit sunt:   
PREZENTARE (cod_pr, data, oras, nume)   
SPONSOR (cod_sponsor, nume, info ,tara_origine)   
SUSTINE (cod_pr, cod_sp, suma)   
VESTIMENTATIE(cod_vestimentatie, denumire, valoare, cod_prezentare)  

Exerciţii:  
1. Adăugaţi constrângerea de cheie externă dintre tabelele PREZENTARE şi VESTIMENTATIE. 
Implementaţi comportamentul ON DELETE CASCADE cu ajutorul unui trigger. Testaţi trigger-ul. 
(3p)  
2. Să se creeze un subprogram prin care se obţine media valorilor oferite de un sponsor al cărui 
cod este introdus ca parametru, pentru prezentările în care au existat minim x vestimentatii. 
Parametrul x va avea valoarea implicita  
3. Să se apeleze subprogramul. (3p) 3. Să se creeze un trigger prin care la inserarea unei noi 
vestimentații pentru o prezentare, suma valorilor vestimentațiilor rămâne mai mică decât suma 
sponsorizărilor. Altfel, apare o excepție. (3p) 

PREZENTARE (cod_pr, data, oras, nume)   
SPONSOR (cod_sponsor, nume, info ,tara_origine)   
SUSTINE (cod_pr, cod_sp, suma)   
VESTIMENTATIE(cod_vestimentatie, denumire, valoare, cod_prezentare)
*/

-- 1. constraint

ALTER TABLE VESTIMENTATIE
  ADD CONSTRAINT fk_vest_prez
  FOREIGN KEY (cod_prezentare)
  REFERENCES PREZENTARE(cod_pr);

CREATE OR REPLACE TRIGGER trg_prezentare_del_cascade
BEFORE DELETE ON PREZENTARE
FOR EACH ROW
BEGIN
  DELETE FROM VESTIMENTATIE
  WHERE cod_prezentare = :OLD.cod_pr;
END;


-- 08.29

-- CREAREA TABELELOR
SET SERVEROUTPUT ON;
CREATE TABLE FORMATIE (
    id_formatie   NUMBER PRIMARY KEY,
    nume          VARCHAR2(100) NOT NULL,
    data_lansare  DATE,
    data_retragere DATE,
    website       VARCHAR2(200),
    tara_prov     VARCHAR2(50)
);

CREATE TABLE PREMIU (
    id_premiu   NUMBER PRIMARY KEY,
    concurs     VARCHAR2(100) NOT NULL,
    sectiune    VARCHAR2(100),
    frecventa   VARCHAR2(50),
    tara_prov   VARCHAR2(50)
);

CREATE TABLE CASTIGA (
    id_premiu    NUMBER,
    id_formatie  NUMBER,
    data_d       DATE,
    loc_ocupat   NUMBER,
    recompensa   VARCHAR2(100),
    PRIMARY KEY (id_premiu, id_formatie, data_d),
    FOREIGN KEY (id_premiu) REFERENCES PREMIU(id_premiu),
    FOREIGN KEY (id_formatie) REFERENCES FORMATIE(id_formatie)
);

CREATE TABLE ALBUM (
    id_album     NUMBER PRIMARY KEY,
    id_formatie  NUMBER,
    gen          VARCHAR2(50),
    nume         VARCHAR2(100),
    data_l       DATE,
    pret         NUMBER(8,2),
    FOREIGN KEY (id_formatie) REFERENCES FORMATIE(id_formatie)
);

-- INSERARE VALORI DEMO

-- FORMATIE
INSERT INTO FORMATIE VALUES (1, 'Metallica', TO_DATE('1981-10-01','YYYY-MM-DD'), NULL, 'https://www.metallica.com', 'USA');
INSERT INTO FORMATIE VALUES (2, 'ABBA', TO_DATE('1972-01-01','YYYY-MM-DD'), TO_DATE('1982-12-31','YYYY-MM-DD'), 'https://www.abbasite.com', 'Sweden');
INSERT INTO FORMATIE VALUES (3, 'Phoenix', TO_DATE('1962-01-01','YYYY-MM-DD'), NULL, 'https://www.phoenix.ro', 'Romania');

-- PREMIU
INSERT INTO PREMIU VALUES (1, 'Grammy Awards', 'Best Metal Performance', 'Anual', 'USA');
INSERT INTO PREMIU VALUES (2, 'Eurovision', 'Best Song', 'Anual', 'Europe');
INSERT INTO PREMIU VALUES (3, 'MTV Music Awards', 'Best Band', 'Anual', 'USA');

-- CASTIGA
INSERT INTO CASTIGA VALUES (1, 1, TO_DATE('1992-02-20','YYYY-MM-DD'), 1, 'Trofeu + 10.000$');
INSERT INTO CASTIGA VALUES (2, 2, TO_DATE('1974-04-06','YYYY-MM-DD'), 1, 'Trofeu');
INSERT INTO CASTIGA VALUES (3, 3, TO_DATE('2010-11-07','YYYY-MM-DD'), 2, 'Diploma + promovare');

-- ALBUM
INSERT INTO ALBUM VALUES (1, 1, 'Metal', 'Master of Puppets', TO_DATE('1986-03-03','YYYY-MM-DD'), 19.99);
INSERT INTO ALBUM VALUES (2, 2, 'Pop', 'Waterloo', TO_DATE('1974-04-04','YYYY-MM-DD'), 15.50);
INSERT INTO ALBUM VALUES (3, 3, 'Rock', 'Mugur de fluier', TO_DATE('1974-01-01','YYYY-MM-DD'), 12.00);
INSERT INTO ALBUM VALUES (4, 1, 'Metal', 'Black Album', TO_DATE('1991-08-12','YYYY-MM-DD'), 21.50);


/*

FORMATIE ( id_formatie, nume, data_lansare, data_retragere, website, tara_prov );
PREMIU ( id_premiu, concurs, sectiune, frecventa, tara_prov );
CASTIGA ( id_Premiu, id_formatie, data_d, loc_ocupat, recompensa);
ALBUM ( id_album, id_formatie, gen, nume, data_l, pret);

1. subprogram ( functie/procedura ) - primeste cod de formatie 
> returneaza lista albumelor lansate de formatie + lista premiilor castigate dupa fiecare album lansat  // data_l < data_d 
testare cu bloc anonim (PL/SQL)
*/

SELECT * FROM formatie;
SELECT * FROM premiu;
SELECT * FROM castiga;
SELECT * FROM album;


CREATE OR REPLACE TYPE l_lista AS OBJECT(
    nume_album VARCHAR2(100),
    gen        VARCHAR2(50),
    recompensa VARCHAR2(100)
);

CREATE OR REPLACE TYPE tabel AS TABLE OF l_lista;

CREATE OR REPLACE FUNCTION f_functie (p_cod IN formatie.id_formatie%TYPE)
RETURN tabel
IS
    v_tab tabel := tabel(); --colectie goala
BEGIN
    SELECT l_lista(a.nume, a.gen, c.recompensa)
    BULK COLLECT INTO v_tab
    FROM formatie f
    LEFT JOIN album a ON a.id_formatie = f.id_formatie
    LEFT JOIN castiga c ON c.id_formatie = f.id_formatie
                        AND c.data_d > a.data_l -- conditie
    WHERE f.id_formatie = p_cod;
    RETURN v_tab;
END;

-- bloc anonim cu for loop
BEGIN
  FOR r IN (SELECT * FROM TABLE(f_functie(1))) LOOP  -- 1 = id_formatie de test
    DBMS_OUTPUT.PUT_LINE(
      'Album: ' || NVL(r.nume_album,'-') || ' | Gen: ' ||r.gen || ' | Recompensa: ' || r.recompensa);
  END LOOP;
END;

/*

2. Definiti un tabel care sa contina o coloana de tip obiect si o coloana de tip tablou
Folositi un subprogram care sa populeze tabelul definit anterior cu cel putin 3 linii

*/

-- creare tip obiect
CREATE OR REPLACE TYPE un_obiect AS OBJECT(
    altceva NUMBER
);

-- creare tip tablou
CREATE OR REPLACE TYPE t_tablou AS TABLE OF VARCHAR2(20);

-- creare tabel cu tip obiect si tip tablou
CREATE TABLE nume_tabel(coloana_obiect un_obiect,coloana_tablou t_tablou) NESTED TABLE coloana_tablou STORE AS coloana_tablou_nt;

-- creare subprogram ( procedura ) cu inserare in tabel 
CREATE OR REPLACE PROCEDURE p_populare IS
BEGIN
    INSERT INTO nume_tabel(coloana_obiect, coloana_tablou)
    VALUES(un_obiect(1), t_tablou('ceva'));
    INSERT INTO nume_tabel(coloana_obiect, coloana_tablou)
    VALUES(un_obiect(2), t_tablou('altceva'));
    INSERT INTO nume_tabel(coloana_obiect, coloana_tablou)
    VALUES(un_obiect(3), t_tablou('incaceva'));
END;

-- executare procedura 
EXEC p_populare;

-- afisare obiect
SELECT t.coloana_obiect.altceva
FROM nume_tabel t;

-- afisare obiect si tablou din tabel
SELECT t.coloana_obiect.altceva,
    x.COLUMN_VALUE AS elem_tablou
FROM nume_tabel t 
CROSS JOIN TABLE(t.coloana_tablou) x;

/*
3. Implementati constrangerea conform careia o formatie nu poate castiga premii daca nu a lansat cel putin un album inainte de data decernarii
premiului. Comentati
*/

/*
4. Definiti un tip de date stocat care sa va permita sa salvati continutul tabelului ALBUM.
Afisati continutul unei variabile de acest tip dupa initializarea acesteia cu informatiile care se regasesc in tabelul ALBUM 
*/

-- creare tip de date stocte ( obiect ) 
CREATE OR REPLACE TYPE t_album AS OBJECT(
    id_album NUMBER,
    id_formatie NUMBER,
    gen          VARCHAR2(50),
    nume         VARCHAR2(100),
    data_l      DATE,
    pret        NUMBER(8,2)
);
-- tip tablou
CREATE OR REPLACE TYPE unalt_tablou AS TABLE OF t_album;

DECLARE
    v_alb unalt_tablou;
BEGIN
    SELECT t_album(id_album, id_formatie, gen, nume, data_l, pret)
    BULK COLLECT INTO v_alb
    FROM album
    ORDER BY data_l NULLS LAST, id_album;
    
    IF v_alb IS NULL OR v_alb.COUNT = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Albumul este gol.');
    ELSE
        FOR i in 1 .. v_alb.COUNT LOOP
            dbms_output.put_line( v_alb(i).id_album || ' ' || v_alb(i).id_formatie || ' ' || v_alb(i).gen );
        END LOOP;
    END IF;
END;


