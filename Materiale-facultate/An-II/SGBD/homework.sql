-- Varianta 1

SUBPROGRAME!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
= functii   ( functions )     - CREATE OR REPLACE FUNCTION <NUME>
= proceduri ( procedures )    - CREATE OR REPLACE PROCEDURE <NUME>

OBIECTE!!!!!!!!! 
= CREATE OR REPLACE TYPE <NUME> AS OBJECT();

TRIGGERE !!!!!!!!!!!!!!!!!!!!!!!!!!
= CREATE OR REPLACE TRIGGER <NUME>

COLECTIE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
= VARRAY - CREATE TYPE <NUME> AS VARRAY(dimensiune) OF NUMBER
= NESTED TABLE - CREATE TYPE <NUME> AS TABLE OF VARCHAR2(50);

În SQL poți folosi VARRAY și Nested Table.
În PL/SQL poți folosi și Associative Array.


EXEMPLU Procedura

    CREATE OR REPLACE PROCEDURE salut_procedura (p_nume IN VARCHAR2) IS
    BEGIN
       DBMS_OUTPUT.PUT_LINE('Salut, ' || p_nume || '!');
    END;
    
    -- apelare
    BEGIN
       salut_procedura('Andrei');
    END;

EXEMPLU FUNCTIE 

    CREATE OR REPLACE FUNCTION calculeaza_tva (p_valoare IN NUMBER)
    RETURN NUMBER IS
       v_tva NUMBER;
    BEGIN
       v_tva := p_valoare * 0.19; -- 19% TVA
       RETURN v_tva;
    END;
    
    BEGIN
    DBMS_OUTPUT.PUT_LINE('TVA: ' || calculeaza_tva(100));
    END;

EXEMPLU TRIGGER


select * from pacienti;

SET SERVEROUTPUT ON;
SAVEPOINT test;
ROLLBACK TO SAVEPOINT test;

-- 1) Funcții (roluri)
CREATE TABLE functii (
  functie_id   NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume_functie VARCHAR2(50) NOT NULL,
  CONSTRAINT pk_functii PRIMARY KEY (functie_id),
  CONSTRAINT uq_functii UNIQUE (nume_functie)
);

-- 2) Angajați
CREATE TABLE angajati (
  angajat_id  NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume        VARCHAR2(50) NOT NULL,
  prenume     VARCHAR2(50) NOT NULL,
  functie_id  NUMBER NOT NULL,
  CONSTRAINT pk_angajati PRIMARY KEY (angajat_id),
  CONSTRAINT fk_angajati_functii FOREIGN KEY (functie_id)
    REFERENCES functii(functie_id)
);

-- 3) Pacienți
CREATE TABLE pacienti (
  pacient_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  nume       VARCHAR2(50) NOT NULL,
  prenume    VARCHAR2(50) NOT NULL,
  gen        CHAR(1) NOT NULL,
  CONSTRAINT pk_pacienti PRIMARY KEY (pacient_id),
  CONSTRAINT ck_gen CHECK (gen IN ('F','M'))
);

-- 4) Îngrijiri (relație M:N între angajat și pacient)
CREATE TABLE ingrijiri (
  ingrijire_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  angajat_id   NUMBER NOT NULL,
  pacient_id   NUMBER NOT NULL,
  data_ingrijire DATE NOT NULL,
  CONSTRAINT pk_ingrijiri PRIMARY KEY (ingrijire_id),
  CONSTRAINT fk_ingrijiri_ang FOREIGN KEY (angajat_id) REFERENCES angajati(angajat_id),
  CONSTRAINT fk_ingrijiri_pac FOREIGN KEY (pacient_id) REFERENCES pacienti(pacient_id)
);
-- Funcții
INSERT INTO functii (nume_functie) VALUES ('Medic');
INSERT INTO functii (nume_functie) VALUES ('Asistent');
INSERT INTO functii (nume_functie) VALUES ('Fizioterapeut');

-- Angajați
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Ionescu',  'Ana',   2); -- Asistent
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Popescu',  'Mihai', 1); -- Medic
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Georgescu','Elena', 2); -- Asistent
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Matei',    'Radu',  3); -- Fizioterapeut
INSERT INTO angajati (nume, prenume, functie_id) VALUES ('Stan',     'Ioana', 1); -- Medic

-- Pacienți
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Dumitru','Maria','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Enache','Andrei','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Tudor','Irina','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Cristea','Vlad','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Nistor','Oana','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Neagu','Paul','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Gavrila','Bianca','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Ilie','Sorin','M');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Petrescu','Anca','F');
INSERT INTO pacienti (nume, prenume, gen) VALUES ('Moldovan','Dragos','M');

-- Îngrijiri (mapare angajat–pacient, unele repetate)
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 1, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 2, DATE '2025-05-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 3, DATE '2025-05-12');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 4, DATE '2025-05-13');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (1, 1, DATE '2025-05-20');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 5, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 6, DATE '2025-05-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 7, DATE '2025-05-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 8, DATE '2025-05-12');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (2, 6, DATE '2025-05-20');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3, 1, DATE '2025-06-01');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3, 9, DATE '2025-06-02');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (3,10, DATE '2025-06-03');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 2, DATE '2025-06-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 3, DATE '2025-06-10');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 4, DATE '2025-06-11');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (4, 7, DATE '2025-06-12');

INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 5, DATE '2025-06-15');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 8, DATE '2025-06-16');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 9, DATE '2025-06-17');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5,10, DATE '2025-06-18');
INSERT INTO ingrijiri (angajat_id, pacient_id, data_ingrijire) VALUES (5, 9, DATE '2025-06-25');

COMMIT;

SELECT * FROM pacienti;
SELECT * FROM angajati;
SELECT * FROM functii;
SELECT * FROM ingrijiri;

/*

1. Scrieti un subprogram care returneaza o evidenta cu privire la numarul de pacienti, de 
fiecare gen, pe care i-a ingrijit fiecare angajat. Subprogramul va returna o singura 
vaiabila de tiplu lista de obiecte( pentru fiecare angajat se returneaza codul numele 
functiei detinute, numarul de pacienti de gen feminin, respectiv masculin ingrijiti).

- subprogram ( procedure sau function )
- returneaza nr_pacienti, de fiecare gen < pe care i-a ingrijit fiecare angajat
- returneaza o singura variabila - de tip lista de obiecte  ( type .. as OBJECT ; type .. as TABLE OF .. ) 
- pentru fiecare angajat - se returneaza cod,nume_functie,numar_pacienti_feminin/masculin

*/

SET SERVEROUTPUT ON;
SAVEPOINT test;

DESCRIBE angajati;

-- Obiectul care descrie evidența pentru un angajat
CREATE OR REPLACE TYPE obiect_evidenta AS OBJECT (
  angajat_id   NUMBER,
  nume_complet VARCHAR2(120),
  functie      VARCHAR2(50),
  nr_femei     NUMBER,
  nr_barbati   NUMBER
);

-- Lista (nested table) de astfel de obiecte
CREATE OR REPLACE TYPE tabel AS TABLE OF obiect_evidenta;

-- Functia
CREATE OR REPLACE FUNCTION functie_evidenta
  RETURN tabel
IS
  l_tab tabel;
BEGIN
  SELECT obiect_evidenta(
           a.angajat_id,
           a.nume || ' ' || a.prenume,
           f.nume_functie,
           /* nr pacienți F distincti */
           COUNT(DISTINCT CASE WHEN p.gen = 'F' THEN p.pacient_id END),
           /* nr pacienți M distincti */
           COUNT(DISTINCT CASE WHEN p.gen = 'M' THEN p.pacient_id END)
         )
  BULK COLLECT INTO l_tab
  FROM angajati a
  JOIN functii f         ON f.functie_id  = a.functie_id
  LEFT JOIN ingrijiri i  ON i.angajat_id  = a.angajat_id
  LEFT JOIN pacienti p   ON p.pacient_id  = i.pacient_id
  GROUP BY a.angajat_id, a.nume, a.prenume, f.nume_functie
  ORDER BY a.angajat_id;

  RETURN l_tab;
END;

-- apelam functia
SELECT *
FROM TABLE(functie_evidenta());


SELECT * FROM specializari;

/* 

2. Trigger care la stergerea unui angajat care este manager de specializare, pune in locul 
acestuia angajatul care a avut cei mai multi pacienti ( si codul cel mai mic daca sunt 2 cu 
aceasta proprietate ) 

-- trigger > la stergerea unui angajat - where spec=manager > angajat where nr_pacienti max top FETCH FIRST 2 ROWS WITH TIES; 

3. Subprogram care primeste ca parametru un cod de functie si returneaza prin intermediul 
unui cursor lista odronata descrescator in functie de salariu, respectiv de cod a 
angajatilor care nu au tratat pacienti si au functia transmisa. 

- subprogram ( functie/procedura ) < primeste cod_functie 
> returneaza prin cursor lista ordonata descrescator in functie de salariu / cod care nu au tratat pacienti si au functia transmisa 

*/
SELECT * FROM pacienti;
SELECT * FROM angajati;

-- subprogram ( procedura ) < primeste cod_functie (p_functie_id IN ... )
CREATE OR REPLACE PROCEDURE p_procedura (p_functie_id IN angajati.functie_id%TYPE)
IS
    -- prin intermediul unui cursor
    CURSOR c IS
        SELECT a.angajat_id,
               a.nume,
               a.prenume,
               a.salariu
        FROM angajati a
        WHERE a.functie_id = p_functie_id
            AND NOT EXISTS ( SELECT 1 
                             FROM ingrijiri i
                             WHERE i.angajat_id = a.angajat_id)
        ORDER BY a.salariu DESC NULLS LAST,
                 a.angajat_id DESC;
BEGIN
    FOR rec IN c LOOP
        DBMS_OUTPUT.PUT_LINE('ID=' || rec.angajat_id || ', ' || rec.nume || ' ' || rec.prenume || ', Salariu= ' || rec.salariu);
    END LOOP;
END;

EXEC p_procedura(1);


-- Varianta 2
/*
AGENTIE_IMOBILIARA ( id_agentie, denumire, clasificare ) 
TRANZACTIONEAZA(cod_agentie, cod_imobil, data_tranzactiei, tip, valoare_comision, pret)  - unde tip inseamna vanzare/inchiriere  
IMOBIL(id_imobil, adresa, cod_proprietar, tip) unde tip inseamna casa, teren sau apartament 
PROPRIETAR(id_proprietar, nume) 


1. Adaugati o coloana de tip colectie la AGENTIE_IMOBILIARA care sa contina numarul de 
tranzactii de tip vanzare si numarul de inchirieri efectuate de 
fiecare agentie. Presupunand ca acesteau au fost actualizate, modificati clasificarea fiecarei 
agentii in functie de numarul de preponderent in 'rent', daca 
numarul de inchirieri efectuate este mai mare, sau in 'sales' in caz contrar.
*/
SELECT * FROM AGENTIE_IMOBILIARA;
DESC AGENTIE_IMOBILIARA;

-- creaza tabele
CREATE TABLE agentie_imobiliara ( id_agentie NUMBER, denumire VARCHAR(50), clasificare VARCHAR(20));
CREATE TABLE tranzactioneaza ( cod_agentie NUMBER, cod_imobil NUMBER, data_tranzactiei DATE, tip VARCHAR(20), valoare_comision NUMBER, pret NUMBER);
CREATE TABLE imobil (id_imobil NUMBER, adresa VARCHAR(100), cod_proprietar NUMBER, tip VARCHAR(15));
CREATE TABLE proprietar (id_proprietar NUMBER, nume VARCHAR(50));

-- insereaza in tabele
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 1, 'Agentie 1', 'ceva' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 2, 'Agentie 2', 'altceva' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 3, 'Agentie 3', 'zzz' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 4, 'Agentie 4', 'vvv' );
INSERT INTO agentie_imobiliara ( id_agentie, denumire, clasificare )
VALUES ( 5, 'Agentie 5', 'ccc' );

SELECT * FROM agentie_imobiliara;
SELECT * FROM tranzactioneaza;

DESC agentie_imobiliara;
-- colectie = varray
CREATE OR REPLACE TYPE v_colectie AS VARRAY(2) OF NUMBER;
ALTER TABLE AGENTIE_IMOBILIARA ADD ( tranz_stat v_colectie );

-- populeaza tranz_stat ( care sa contina din cerinta )
UPDATE AGENTIE_IMOBILIARA a
SET tranz_stat = v_colectie(NVL ((SELECT COUNT(*) FROM tranzactioneaza t WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale'), 0 ),
    NVL((SELECT COUNT(*) FROM tranzactioneaza t WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent'), 0)
);

UPDATE agentie_imobiliara a
SET clasificare =
  CASE
    WHEN (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent')
       > (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale')
      THEN 'rent'
    WHEN (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'sale')
       > (SELECT COUNT(*) FROM tranzactioneaza t
            WHERE t.cod_agentie = a.id_agentie AND t.tip = 'rent')
      THEN 'sales'
    ELSE 'none'  
  END;
  
/* 2.
 Creati un subprogram pentru care ii transmiteti un an transmis ca parametru, afisati pentru 
fiecare agentie : denumirea ei, adresa tuturor imobilelor pe care 
le-a tranzactionat si totalul care l-a obtinut din acestea. 
*/

SELECT * FROM TRANZACTIONEAZA;
SELECT * FROM IMOBIL;
DESCRIBE imobil;
DESCRIBE agentie_imobiliara;

CREATE OR REPLACE PROCEDURE p_raport_agentii_pe_an (p_an IN NUMBER)
IS
BEGIN
  FOR r IN (
    SELECT a.denumire,
           i.adresa,
           SUM(t.valoare_comision) OVER (PARTITION BY a.id_agentie) AS total_obtinut
    FROM agentie_imobiliara a
    JOIN tranzactioneaza t ON t.cod_agentie = a.id_agentie
    JOIN imobil          i ON i.id_imobil   = t.cod_imobil
    WHERE EXTRACT(YEAR FROM t.data_tranzactiei) = p_an
    ORDER BY a.denumire, i.adresa
  ) LOOP
    DBMS_OUTPUT.PUT_LINE('Agentie: ' || r.denumire ||
                         ', Imobil: ' || r.adresa ||
                         ', Total: ' || r.total_obtinut);
  END LOOP;
END;

EXEC p_raport_agentii_pe_an(2024);

/*
5. Creati un subprogram care pentru un nume de proprietar dat ca parametru, intoarce numarul 
de apartamente care acesta le-a tranzactionat cu firmele care au cele mai 
multe de tranzactii incheiate. Tratati exceptiile ce pot aparea.
*/

SELECT * FROM proprietar;
SELECT * FROM imobil;
SELECT * FROM tranzactioneaza;

CREATE OR REPLACE function f_subprogram (p_nume IN proprietar.nume%TYPE)
 RETURN NUMBER
IS
    v_prop_id proprietar.id_proprietar%TYPE;
    v_max_cnt NUMBER;
    V_nr_ap NUMBER := 0;
BEGIN
    -- identifica proprietarul
    SELECT id_proprietar
        INTO v_prop_id
        FROM proprietar
    WHERE nume = p_nume;
    
    -- numarul maxim de tranzactii pe agentie
    SELECT MAX(cnt)
        INTO v_max_cnt
        FROM ( 
            SELECT cod_agentie, COUNT(*) as cnt
            FROM tranzactioneaza
            GROUP BY cod_agentie
        );
    IF v_max_cnt IS NULL THEN
        RETURN 0;
    END IF;

    -- numar de apartamente distinct tranzactionate
    SELECT COUNT(DISTINCT t.cod_imobil)
        INTO v_nr_ap
        FROM tranzactioneaza t
        JOIN imobil i ON i.id_imobil = t.cod_imobil
    WHERE i.cod_proprietar = v_prop_id
        AND i.tip = 'apartament'
        AND t.cod_agentie IN (
            SELECT cod_agentie
            FROM ( 
                SELECT cod_agentie, COUNT(*) AS cnt
                FROM tranzactioneaza
                GROUP BY cod_agentie
            )
            WHERE cnt = v_max_cnt
        );
    RETURN v_nr_ap;
END;
    
SELECT f_subprogram('Stan Elena') AS nr_apartamente FROM dual;


SELECT 
    count(*) cod_imobil,
    p.nume,
    t.cod_agentie
FROM imobil i
JOIN proprietar p ON p.id_proprietar = i.cod_proprietar
JOIN tranzactioneaza t ON t.cod_imobil = i.id_imobil
--WHERE p.id_proprietar = 3
GROUP BY t.cod_agentie, p.nume

/*
Varianta 3 
Schemele relaţionale ale modelului folosit sunt:   
PREZENTARE (cod_pr, data, oras, nume)   
SPONSOR (cod_sponsor, nume, info ,tara_origine)   
SUSTINE (cod_pr, cod_sp, suma)   
VESTIMENTATIE(cod_vestimentatie, denumire, valoare, cod_prezentare)  

Exerciţii:  
1. Adăugaţi constrângerea de cheie externă dintre tabelele PREZENTARE şi VESTIMENTATIE. 
Implementaţi comportamentul ON DELETE CASCADE cu ajutorul unui trigger. Testaţi trigger-ul. 
(3p)  
2. Să se creeze un subprogram prin care se obţine media valorilor oferite de un sponsor al cărui 
cod este introdus ca parametru, pentru prezentările în care au existat minim x vestimentatii. 
Parametrul x va avea valoarea implicita  
3. Să se apeleze subprogramul. (3p) 3. Să se creeze un trigger prin care la inserarea unei noi 
vestimentații pentru o prezentare, suma valorilor vestimentațiilor rămâne mai mică decât suma 
sponsorizărilor. Altfel, apare o excepție. (3p) 

PREZENTARE (cod_pr, data, oras, nume)   
SPONSOR (cod_sponsor, nume, info ,tara_origine)   
SUSTINE (cod_pr, cod_sp, suma)   
VESTIMENTATIE(cod_vestimentatie, denumire, valoare, cod_prezentare)
*/

-- 1. constraint

ALTER TABLE VESTIMENTATIE
  ADD CONSTRAINT fk_vest_prez
  FOREIGN KEY (cod_prezentare)
  REFERENCES PREZENTARE(cod_pr);

CREATE OR REPLACE TRIGGER trg_prezentare_del_cascade
BEFORE DELETE ON PREZENTARE
FOR EACH ROW
BEGIN
  DELETE FROM VESTIMENTATIE
  WHERE cod_prezentare = :OLD.cod_pr;
END;


-- 08.29

-- CREAREA TABELELOR
SET SERVEROUTPUT ON;
CREATE TABLE FORMATIE (
    id_formatie   NUMBER PRIMARY KEY,
    nume          VARCHAR2(100) NOT NULL,
    data_lansare  DATE,
    data_retragere DATE,
    website       VARCHAR2(200),
    tara_prov     VARCHAR2(50)
);

CREATE TABLE PREMIU (
    id_premiu   NUMBER PRIMARY KEY,
    concurs     VARCHAR2(100) NOT NULL,
    sectiune    VARCHAR2(100),
    frecventa   VARCHAR2(50),
    tara_prov   VARCHAR2(50)
);

CREATE TABLE CASTIGA (
    id_premiu    NUMBER,
    id_formatie  NUMBER,
    data_d       DATE,
    loc_ocupat   NUMBER,
    recompensa   VARCHAR2(100),
    PRIMARY KEY (id_premiu, id_formatie, data_d),
    FOREIGN KEY (id_premiu) REFERENCES PREMIU(id_premiu),
    FOREIGN KEY (id_formatie) REFERENCES FORMATIE(id_formatie)
);

CREATE TABLE ALBUM (
    id_album     NUMBER PRIMARY KEY,
    id_formatie  NUMBER,
    gen          VARCHAR2(50),
    nume         VARCHAR2(100),
    data_l       DATE,
    pret         NUMBER(8,2),
    FOREIGN KEY (id_formatie) REFERENCES FORMATIE(id_formatie)
);

-- INSERARE VALORI DEMO

-- FORMATIE
INSERT INTO FORMATIE VALUES (1, 'Metallica', TO_DATE('1981-10-01','YYYY-MM-DD'), NULL, 'https://www.metallica.com', 'USA');
INSERT INTO FORMATIE VALUES (2, 'ABBA', TO_DATE('1972-01-01','YYYY-MM-DD'), TO_DATE('1982-12-31','YYYY-MM-DD'), 'https://www.abbasite.com', 'Sweden');
INSERT INTO FORMATIE VALUES (3, 'Phoenix', TO_DATE('1962-01-01','YYYY-MM-DD'), NULL, 'https://www.phoenix.ro', 'Romania');

-- PREMIU
INSERT INTO PREMIU VALUES (1, 'Grammy Awards', 'Best Metal Performance', 'Anual', 'USA');
INSERT INTO PREMIU VALUES (2, 'Eurovision', 'Best Song', 'Anual', 'Europe');
INSERT INTO PREMIU VALUES (3, 'MTV Music Awards', 'Best Band', 'Anual', 'USA');

-- CASTIGA
INSERT INTO CASTIGA VALUES (1, 1, TO_DATE('1992-02-20','YYYY-MM-DD'), 1, 'Trofeu + 10.000$');
INSERT INTO CASTIGA VALUES (2, 2, TO_DATE('1974-04-06','YYYY-MM-DD'), 1, 'Trofeu');
INSERT INTO CASTIGA VALUES (3, 3, TO_DATE('2010-11-07','YYYY-MM-DD'), 2, 'Diploma + promovare');

-- ALBUM
INSERT INTO ALBUM VALUES (1, 1, 'Metal', 'Master of Puppets', TO_DATE('1986-03-03','YYYY-MM-DD'), 19.99);
INSERT INTO ALBUM VALUES (2, 2, 'Pop', 'Waterloo', TO_DATE('1974-04-04','YYYY-MM-DD'), 15.50);
INSERT INTO ALBUM VALUES (3, 3, 'Rock', 'Mugur de fluier', TO_DATE('1974-01-01','YYYY-MM-DD'), 12.00);
INSERT INTO ALBUM VALUES (4, 1, 'Metal', 'Black Album', TO_DATE('1991-08-12','YYYY-MM-DD'), 21.50);


/*

FORMATIE ( id_formatie, nume, data_lansare, data_retragere, website, tara_prov );
PREMIU ( id_premiu, concurs, sectiune, frecventa, tara_prov );
CASTIGA ( id_Premiu, id_formatie, data_d, loc_ocupat, recompensa);
ALBUM ( id_album, id_formatie, gen, nume, data_l, pret);

1. subprogram ( functie/procedura ) - primeste cod de formatie 
> returneaza lista albumelor lansate de formatie + lista premiilor castigate dupa fiecare album lansat  // data_l < data_d 
testare cu bloc anonim (PL/SQL)
*/

SELECT * FROM formatie;
SELECT * FROM premiu;
SELECT * FROM castiga;
SELECT * FROM album;


CREATE OR REPLACE TYPE l_lista AS OBJECT(
    nume_album VARCHAR2(100),
    gen        VARCHAR2(50),
    recompensa VARCHAR2(100)
);

CREATE OR REPLACE TYPE tabel AS TABLE OF l_lista;

CREATE OR REPLACE FUNCTION f_functie (p_cod IN formatie.id_formatie%TYPE)
RETURN tabel
IS
    v_tab tabel := tabel(); --colectie goala
BEGIN
    SELECT l_lista(a.nume, a.gen, c.recompensa)
    BULK COLLECT INTO v_tab
    FROM formatie f
    LEFT JOIN album a ON a.id_formatie = f.id_formatie
    LEFT JOIN castiga c ON c.id_formatie = f.id_formatie
                        AND c.data_d > a.data_l -- conditie
    WHERE f.id_formatie = p_cod;
    RETURN v_tab;
END;

-- bloc anonim cu for loop
BEGIN
  FOR r IN (SELECT * FROM TABLE(f_functie(1))) LOOP  -- 1 = id_formatie de test
    DBMS_OUTPUT.PUT_LINE(
      'Album: ' || NVL(r.nume_album,'-') || ' | Gen: ' ||r.gen || ' | Recompensa: ' || r.recompensa);
  END LOOP;
END;

/*

2. Definiti un tabel care sa contina o coloana de tip obiect si o coloana de tip tablou
Folositi un subprogram care sa populeze tabelul definit anterior cu cel putin 3 linii

*/

-- creare tip obiect
CREATE OR REPLACE TYPE un_obiect AS OBJECT(
    altceva NUMBER
);

-- creare tip tablou
CREATE OR REPLACE TYPE t_tablou AS TABLE OF VARCHAR2(20);

-- creare tabel cu tip obiect si tip tablou
CREATE TABLE nume_tabel(coloana_obiect un_obiect,coloana_tablou t_tablou) NESTED TABLE coloana_tablou STORE AS coloana_tablou_nt;

-- creare subprogram ( procedura ) cu inserare in tabel 
CREATE OR REPLACE PROCEDURE p_populare IS
BEGIN
    INSERT INTO nume_tabel(coloana_obiect, coloana_tablou)
    VALUES(un_obiect(1), t_tablou('ceva'));
    INSERT INTO nume_tabel(coloana_obiect, coloana_tablou)
    VALUES(un_obiect(2), t_tablou('altceva'));
    INSERT INTO nume_tabel(coloana_obiect, coloana_tablou)
    VALUES(un_obiect(3), t_tablou('incaceva'));
END;

-- executare procedura 
EXEC p_populare;

-- afisare obiect
SELECT t.coloana_obiect.altceva
FROM nume_tabel t;

-- afisare obiect si tablou din tabel
SELECT t.coloana_obiect.altceva,
    x.COLUMN_VALUE AS elem_tablou
FROM nume_tabel t 
CROSS JOIN TABLE(t.coloana_tablou) x;

/*
3. Implementati constrangerea conform careia o formatie nu poate castiga premii daca nu a lansat cel putin un album inainte de data decernarii
premiului. Comentati
*/

/*
4. Definiti un tip de date stocat care sa va permita sa salvati continutul tabelului ALBUM.
Afisati continutul unei variabile de acest tip dupa initializarea acesteia cu informatiile care se regasesc in tabelul ALBUM 
*/

-- creare tip de date stocte ( obiect ) 
CREATE OR REPLACE TYPE t_album AS OBJECT(
    id_album NUMBER,
    id_formatie NUMBER,
    gen          VARCHAR2(50),
    nume         VARCHAR2(100),
    data_l      DATE,
    pret        NUMBER(8,2)
);
-- tip tablou
CREATE OR REPLACE TYPE unalt_tablou AS TABLE OF t_album;

DECLARE
    v_alb unalt_tablou;
BEGIN
    SELECT t_album(id_album, id_formatie, gen, nume, data_l, pret)
    BULK COLLECT INTO v_alb
    FROM album
    ORDER BY data_l NULLS LAST, id_album;
    
    IF v_alb IS NULL OR v_alb.COUNT = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Albumul este gol.');
    ELSE
        FOR i in 1 .. v_alb.COUNT LOOP
            dbms_output.put_line( v_alb(i).id_album || ' ' || v_alb(i).id_formatie || ' ' || v_alb(i).gen );
        END LOOP;
    END IF;
END;


/*

Varianta 8 - 11:21 - 1:00

PERSONAL (id_salariat, nume, prenume, adresa, data_nastere, salariu, id_functie, id_specializare)
PACIENTI (id_pacient, nume, prenume, data_nastere)
TRATEAZA (id_salariat, id_pacient, data_internare, data_externare)
FUNCTII (id_functie, nume_functie, salariu_minim, salariu_maxim)
SPECIALIZARE (id_specializare, nume_specializare, id_manager)

1. Subprogram care primeste ca parametru un cod de angajat si returneaza lista pacientilor de care acesta a avut grija, impreuna
cu numarul de zile de internare pentru fiecare. Apelati

*/
SET SERVEROUTPUT ON;

SELECT  * FROM personal;
SELECT * FROM TRATEAZA;

SELECT
    p.id_salariat,
    p.nume,
    p.prenume,
    pp.nume as nume_pacient,
    pp.prenume as prenume_pacient,
--    LISTAGG(pp.nume || ' ' || pp.prenume, ', ')
--        WITHIN GROUP (ORDER BY pp.nume, pp.prenume),
    sum(t.data_externare - t.data_internare)
FROM personal p
JOIN TRATEAZA t ON t.id_salariat = p.id_salariat
JOIN pacienti pp ON pp.id_pacient = t.id_pacient
WHERE p.id_salariat = 102
GROUP BY p.id_salariat, p.nume, p.prenume, pp.nume, pp.prenume

CREATE OR REPLACE TYPE o_pacient_obiect AS OBJECT (
    id_salariat     NUMBER,
    nume_salariat   VARCHAR2(50),
    prenume_salariat    VARCHAR2(50),
    nume_pacient    VARCHAR2(50),
    prenume_pacient VARCHAR2(50),
    numar_zile_internare    NUMBER
);

CREATE OR REPLACE TYPE t_pacient_tabel AS TABLE OF o_pacient_obiect;

CREATE OR REPLACE PROCEDURE p_pacienti_procedura(p_cod_angajat IN personal.id_salariat%TYPE)
IS
    v_tabel_pacient t_pacient_tabel := t_pacient_tabel();
BEGIN
    SELECT  o_pacient_obiect(
            p.id_salariat,
            p.nume,
            p.prenume,
            pp.nume,
            pp.prenume,
            sum(t.data_externare - t.data_internare)
          )
        BULK COLLECT INTO v_tabel_pacient
        FROM personal p
        JOIN TRATEAZA t ON t.id_salariat = p.id_salariat
        JOIN pacienti pp ON pp.id_pacient = t.id_pacient
        WHERE p.id_salariat = p_cod_angajat
        GROUP BY p.id_salariat, p.nume, p.prenume, pp.nume, pp.prenume;
        
        FOR i in 1 .. v_tabel_pacient.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('Pacient: ' || v_tabel_pacient(i).nume_pacient || ' ' || v_tabel_pacient(i).prenume_pacient || ' Zile internare: ' || v_tabel_pacient(i).numar_zile_internare );
        END LOOP; 
END;

EXEC p_pacienti_procedura(101);

/*

2. Subprogram care afiseaza pentru fiecare functie denumirea acesteia impreuna cu lista angajatilor care au salariul mai mare decat media sal
colegilor ( aceeasi functie ) si care au avut cel putin 2 pacienti. Tratati erorile

*/

SELECT* FROM FUNCTII;
SELECT * FROM PACIENTI;
SELECT * FROM PERSONAL;


WITH medie AS (
    SELECT 
        p.id_functie,
        ROUND(avg(p.salariu),2) AS MEDIE
    FROM personal p    
    GROUP BY id_functie
),
numar AS (
    SELECT 
        p.id_salariat,
        count(t.id_pacient) AS NUMAR
    FROM personal p
    JOIN trateaza t ON t.id_salariat = p.id_salariat
    GROUP BY p.id_salariat
)
SELECT 
    f.id_functie,
    f.nume_functie,
    LISTAGG(DISTINCT p.nume || ' ' || p.prenume, ', ')
        WITHIN GROUP (ORDER BY p.nume, p.prenume),
    m.medie
FROM FUNCTII f
JOIN PERSONAL p ON p.id_functie = f.id_functie
JOIN TRATEAZA t ON t.id_salariat = p.id_salariat
JOIN medie m ON m.id_functie = f.id_functie
JOIN numar n ON n.id_salariat = p.id_salariat
WHERE p.salariu > m.medie AND n.numar >= 3
GROUP BY f.id_functie, f.nume_functie, m.medie


CREATE OR REPLACE TYPE o_functie_denumire AS OBJECT (
        id_functie NUMBER,
        nume_functie VARCHAR2(50),
        nume_angajat VARCHAR2(10000),
        medie NUMBER
);

CREATE OR REPLACE TYPE t_functie_denumire AS TABLE OF o_functie_denumire;

CREATE OR REPLACE PROCEDURE p_functie_denumire
IS
    v_fct t_functie_denumire := t_functie_denumire();
BEGIN
    WITH medie AS (
    SELECT 
        p.id_functie,
        ROUND(avg(p.salariu),2) AS MEDIE
    FROM personal p    
    GROUP BY id_functie
    ),
    numar AS (
        SELECT 
            p.id_salariat,
            count(t.id_pacient) AS NUMAR
        FROM personal p
        JOIN trateaza t ON t.id_salariat = p.id_salariat
        GROUP BY p.id_salariat
    )
    SELECT o_functie_denumire (
        f.id_functie,
        f.nume_functie,
        LISTAGG(DISTINCT p.nume || ' ' || p.prenume, ', ')
            WITHIN GROUP (ORDER BY p.nume, p.prenume),
        m.medie
    ) 
    BULK COLLECT INTO v_fct
    FROM FUNCTII f
    JOIN PERSONAL p ON p.id_functie = f.id_functie
    JOIN TRATEAZA t ON t.id_salariat = p.id_salariat
    JOIN medie m ON m.id_functie = f.id_functie
    JOIN numar n ON n.id_salariat = p.id_salariat
    WHERE p.salariu > m.medie AND n.numar >= 3
    GROUP BY f.id_functie, f.nume_functie, m.medie;
    
    IF v_fct IS NULL THEN
        dbms_output.put_line('Nu exista angajati cu aceste criterii ');
    ELSE 
        FOR i IN 1 .. v_fct.COUNT LOOP
            dbms_output.put_line('Denumire functie: ' || v_fct(i).nume_functie || '  ' || ' Lista angajatilor: ' || v_fct(i).nume_angajat );
        END LOOP;
    END IF;
END;

EXEC p_functie_denumire;



SET SERVEROUTPUT ON;


/*

V9

TURIST(id_turist, nume, prenume, data_nastere);
AGENTIE(id_agentie, denumire, oras);
EXCURSIE(id_excursie, denumire, pret, destinatie, durata, cod_agentie, nr_locuri)
ACHIZITIONEAZA(cod_excursie,cod_turist,data_start,data_end,data_achizitie, discount);

*/


-- Subprogram care primeste ca parametru codul unei agentii si returneaza - lisa ordonata, in funtie de nr de locuri neocupate
-- a excursiilor organizate. Apelati

SELECT * FROM excursie;
SELECT * FROM agentie;
SELECT * FROM achizitioneaza;

CREATE OR REPLACE TYPE o_nr_locuri AS OBJECT (
    numar_locuri NUMBER,
    id_excursie NUMBER,
    numar_locuri_neocupate NUMBER
);

CREATE OR REPLACE TYPE t_nr_locuri AS TABLE OF o_nr_locuri;

CREATE OR REPLACE PROCEDURE p_nr_locuri(p_cod_agentie IN agentie.id_agentie%TYPE)
IS
    v_nr_locuri t_nr_locuri := t_nr_locuri();
BEGIN
    WITH numar_locuri AS(
        SELECT 
            e.id_excursie,
            e.nr_locuri - count(aa.cod_excursie) AS numar_locuri_neocupate
        FROM achizitioneaza aa
        JOIN excursie e ON e.id_excursie = aa.cod_excursie
        JOIN agentie a ON a.id_agentie = e.cod_agentie
        WHERE a.id_agentie =  p_cod_agentie
        GROUP BY e.id_excursie, e.nr_locuri
    )
    SELECT o_nr_locuri(
        e.nr_locuri,
        e.id_excursie,
        nr.numar_locuri_neocupate
    )
    BULK COLLECT INTO v_nr_locuri
    FROM excursie e
    JOIN agentie a ON a.id_agentie = e.cod_agentie
    JOIN achizitioneaza aa ON aa.cod_excursie = e.id_excursie
    JOIN numar_locuri nr ON nr.id_excursie = e.id_excursie
    WHERE a.id_agentie = p_cod_agentie
    GROUP BY e.id_excursie, e.nr_locuri, nr.numar_locuri_neocupate
    ORDER BY nr.numar_locuri_neocupate;
    
    FOR i in 1 .. v_nr_locuri.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Agentie: ' || v_nr_locuri(i).id_excursie || ' ' || ' Numar locuri neocupate: ' || v_nr_locuri(i).numar_locuri_neocupate);
    END LOOP;
END;

EXEC p_nr_locuri(10);


/*
Sa se defineasca tabelul INFO care sa permita stocarea urmatoarelor informatii:
- pentru fiecare agentie(cod) se vor identifica top 3, in functie de durata, excursii(cod, denumire, numar_locuri) organizate
- lista turistilor (cod,nume) care au achizitionat excursii de la fiecare agentie

Dati exemplu de o comanda insert (fara null) care adauga o inregistrare in tabelul INFO
*/

CREATE OR REPLACE TYPE o_lista_top AS OBJECT(
    id_agentie NUMBER,
    cod_excursie VARCHAR2(1000),
    denumire_excursie VARCHAR2(1000),
    numar_locuri VARCHAR2(1000)
);

CREATE OR REPLACE TYPE o_lista_turisti AS OBJECT (
    cod_turist NUMBER,
    nume_turist VARCHAR2(1000)
);

DROP TYPE o_lista_turisti;

CREATE TABLE INFO ( lista_top o_lista_top, lista_turisti o_lista_turisti);

DROP TABLE INFO;

INSERT INTO INFO ( lista_top, lista_turisti )
VALUES(o_lista_top(1,1,'excursie1, excursie2',21), o_lista_turisti(1,'Ion, Marian'));

SELECT * FROM INFO;


/*
Scrieti un subprogram care populeaza cu informatiile existente in baza de date tabelul INFO pentru fiecare agentie 
*/

SELECT * FROM AGENTIE;
SELECT * FROM EXCURSIE;

CREATE OR REPLACE TYPE t_lista_top AS TABLE OF o_lista_top;
CREATE OR REPLACE TYPE t_lista_turisti AS TABLE OF o_lista_turisti;


CREATE OR REPLACE PROCEDURE p_pop_info
IS
    v_lista_top t_lista_top := t_lista_top();
--    v_lista_turisti t_lista_turisti := t_lista_turist();
BEGIN
    WITH ranked AS (
      SELECT
        a.id_agentie,
        e.id_excursie,
        e.denumire,
        e.nr_locuri,
        e.durata,
        ROW_NUMBER() OVER (
          PARTITION BY a.id_agentie
          ORDER BY e.durata DESC, e.id_excursie
        ) AS rn
      FROM agentie a
      JOIN excursie e ON e.cod_agentie = a.id_agentie
    )
    SELECT o_lista_top(
      id_agentie,
      LISTAGG(id_excursie, ', ')
        WITHIN GROUP (ORDER BY durata DESC, id_excursie),
      LISTAGG(denumire, ', ')
        WITHIN GROUP (ORDER BY durata DESC, denumire),
      LISTAGG(nr_locuri, ', ')
        WITHIN GROUP (ORDER BY durata DESC, nr_locuri)
    )
    BULK COLLECT INTO v_lista_top
    FROM ranked
    WHERE rn <= 3
    GROUP BY id_agentie;
    
    IF v_lista_top.COUNT > 0 THEN
      FORALL i IN 1..v_lista_top.COUNT
        INSERT INTO info (lista_top)
        VALUES (v_lista_top(i));     -- vezi nota de mai jos pentru lista_turisti
    END IF;
END;

BEGIN
    p_pop_info;
    COMMIT;
END;

SELECT
  i.lista_top.id_agentie        AS id_agentie,
  i.lista_top.cod_excursie      AS cod_excursie,
  i.lista_top.denumire_excursie AS denumire_excursie,
  i.lista_top.numar_locuri      AS numar_locuri
FROM info i;


-- 5:18 - 6:23 = ~1hr

SELECT * FROM EMPLOYEES;

/*
V10
FIRMA(cod_f, denumire, data_inf, capital, director)
ANGAJAT(cod_ang, nume, data_nastere, salariu, cod_firma)
LUCREAZA(cod_angajat, id_utilaj, nr_ore, data)
UTILAJ(id_utilaj, denumire, data_achizitiei, valoare)
*/

--1) Definiti un tabel care sa contina o coloana de tip obiect si o coloana de tip tablou
-- folositi un bloc anonim care sa populeze tabelul definit anterior cu cel putin 3 linii

SET SERVEROUTPUT ON;

CREATE OR REPLACE TYPE o_coloana_obiect_an AS OBJECT (
    un_numar NUMBER
);

CREATE OR REPLACE TYPE o_coloana_tablou_an AS TABLE OF VARCHAR2(100);

-- creare tabel 
CREATE TABLE tabel_anonim (coloana_obiect o_coloana_obiect_an, coloana_tablou o_coloana_tablou_an) NESTED TABLE coloana_tablou STORE AS c_tab;

-- bloc anonim pentru inserare 
BEGIN
    INSERT INTO tabel_anonim(coloana_obiect, coloana_tablou)
    VALUES (o_coloana_obiect_an(1), o_coloana_tablou_an('ceva'));
    INSERT INTO tabel_anonim(coloana_obiect, coloana_tablou)
    VALUES (o_coloana_obiect_an(2), o_coloana_tablou_an('altceva'));
    INSERT INTO tabel_anonim(coloana_obiect, coloana_tablou)
    VALUES (o_coloana_obiect_an(3), o_coloana_tablou_an('inca ceva'));  
END;

SELECT 
    t.coloana_obiect.un_numar
FROM tabel_anonim t

-- 2) Subprogam care populeaza tabelul info cu informatii 
--  pentru fiecare cod de angajat se retin codurile utilajelor pe care le-a folosit si numarul total de ore de munca pe aceste utilaje

SELECT * FROM INFO;
DROP TABLE INFO;

CREATE TABLE info(
    id_angajat NUMBER,
    coduri_utilaje VARCHAR2(1000),
    ore_per_utilaj VARCHAR2(1000)
);


SELECT 
    a.cod_ang,
    LISTAGG(l.id_utilaj, ', ')
        WITHIN GROUP (ORDER BY l.id_utilaj),
    LISTAGG(l.nr_ore, ', ')
        WITHIN GROUP (ORDER BY l.nr_ore)
FROM angajat a
JOIN lucreaza l ON l.cod_angajat = a.cod_ang
GROUP BY a.cod_ang
    
CREATE OR REPLACE TYPE o_tabel_info AS OBJECT(
    id_angajat NUMBER,
    lista_utilaje VARCHAR2(1000),
    lista_ore VARCHAR2(1000)
);
CREATE OR REPLACE TYPE t_tabel_info AS TABLE OF o_tabel_info;

CREATE OR REPLACE PROCEDURE p_tabel_info
IS
    v_tabel_info t_tabel_info := t_tabel_info();
BEGIN
    SELECT o_tabel_info(
        a.cod_ang,
        LISTAGG(l.id_utilaj, ', ')
            WITHIN GROUP (ORDER BY l.id_utilaj),
        LISTAGG(l.nr_ore, ', ')
            WITHIN GROUP (ORDER BY l.nr_ore)
    )
    BULK COLLECT INTO v_tabel_info
    FROM angajat a
    JOIN lucreaza l ON l.cod_angajat = a.cod_ang
    GROUP BY a.cod_ang;
    
    IF v_tabel_info.COUNT > 0 THEN 
        FORALL i in 1..v_tabel_info.COUNT
            INSERT INTO info(id_angajat, coduri_utilaje, ore_per_utilaj)
            VALUES (v_tabel_info(i).id_angajat, v_tabel_info(i).lista_utilaje, v_tabel_info(i).lista_ore); 
    ELSE
         dbms_output.put_line('Nu exista valori');
    END IF;
END;

EXEC p_tabel_info;

SELECT * FROM INFO;

-- 3) Procedura care pentru o luna si un cod de firma, transmise ca parametri, returneaza lista angajatilor care au lucrat mai mult 
-- de 10 ore in luna respectiva


--FIRMA(cod_f, denumire, data_inf, capital, director)
--ANGAJAT(cod_ang, nume, data_nastere, salariu, cod_firma)
--LUCREAZA(cod_angajat, id_utilaj, nr_ore, data)
--UTILAJ(id_utilaj, denumire, data_achizitiei, valoare)

SELECT * FROM angajat;
SELECT * FROM firma;
SELECT * FROM LUCREAZA;


WITH numar_ore AS(
    SELECT
        f.cod_f,
        a.cod_ang,
        sum(l.nr_ore) as numar_ore
    FROM angajat a 
    JOIN firma f ON f.cod_f = a.cod_firma
    JOIN lucreaza l ON l.cod_angajat = a.cod_ang
    WHERE f.cod_f = 10 AND TO_CHAR(l.data, 'FMMonth') = 'November'
    GROUP BY f.cod_f, a.cod_ang
)
SELECT
    f.cod_f,
    a.cod_ang,
    n.numar_ore
FROM angajat a 
JOIN firma f ON f.cod_f = a.cod_firma
JOIN lucreaza l ON l.cod_angajat = a.cod_ang
JOIN numar_ore n ON n.cod_ang = a.cod_ang
WHERE f.cod_f = 10 AND TO_CHAR(l.data, 'FMMonth') = 'November' AND n.numar_ore > 10
GROUP BY f.cod_f, a.cod_ang, n.numar_ore;


CREATE OR REPLACE TYPE o_numar_ore AS OBJECT(
    cod_firma NUMBER,
    cod_ang NUMBER,
    numar_ore NUMBER
);

CREATE OR REPLACE TYPE t_numar_ore AS TABLE OF o_numar_ore;

CREATE OR REPLACE PROCEDURE p_ore_luc(p_luna IN angajat.nume%TYPE, p_cod_firma IN firma.cod_f%TYPE)
IS
    v_numar_ore t_numar_ore := t_numar_ore();
BEGIN
    WITH numar_ore AS(
        SELECT
            f.cod_f,
            a.cod_ang,
            sum(l.nr_ore) as numar_ore
        FROM angajat a 
        JOIN firma f ON f.cod_f = a.cod_firma
        JOIN lucreaza l ON l.cod_angajat = a.cod_ang
        WHERE f.cod_f = p_cod_firma AND TO_CHAR(l.data, 'FMMonth') = p_luna
        GROUP BY f.cod_f, a.cod_ang
    )
    SELECT o_numar_ore(
        f.cod_f,
        a.cod_ang,
        n.numar_ore
    )
    BULK COLLECT INTO v_numar_ore
    FROM angajat a 
    JOIN firma f ON f.cod_f = a.cod_firma
    JOIN lucreaza l ON l.cod_angajat = a.cod_ang
    JOIN numar_ore n ON n.cod_ang = a.cod_ang
    WHERE f.cod_f = p_cod_firma AND TO_CHAR(l.data, 'FMMonth') = p_luna AND n.numar_ore > 10
    GROUP BY f.cod_f, a.cod_ang, n.numar_ore;
    
    FOR i in 1 .. v_numar_ore.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Angajat cu peste 10 ore lucrate: ' || v_numar_ore(i).cod_ang );
    END LOOP;
END;

EXEC p_ore_luc('November', 10);

/*
V11

PRODUS(cod_produs, denumire, pret_vanzare)
COMPANIE(cod, denumire, capital, presedinte)
STATIE(cod_statie, denumire, nr_angajati, cod_companie, capacitate, oras)
ACHIZITIE( cod_st, cod_prod, data_achizitiei, cantitate, pre_achizitie)
*/

-- 1) Subprogram care primeste prin intermediul unui parametru codul unei statii si returneaza lista ordonata - in fcts de cant totala achizitionata
-- produselor comercializate

SELECT * FROM statie;

SELECT
    p.cod_produs,
    p.denumire
FROM produs p
JOIN achizitie a ON a.cod_prod = p.cod_produs
JOIN statie s ON s.cod_statie = a.cod_st
WHERE s.cod_statie = 1001
ORDER BY a.cantitate;

CREATE OR REPLACE TYPE o_cant_prod AS OBJECT(
    id_produs NUMBER,
    denumire VARCHAR2(1000)
);

CREATE OR REPLACE TYPE t_cant_prod AS TABLE OF o_cant_prod;

CREATE OR REPLACE PROCEDURE p_cant_prod(p_cod_statie IN statie.cod_statie%TYPE)
IS
    v_cant_prod t_cant_prod := t_cant_prod();
BEGIN
    SELECT o_cant_prod(
        p.cod_produs,
        p.denumire
    )
    BULK COLLECT INTO v_cant_prod
    FROM produs p
    JOIN achizitie a ON a.cod_prod = p.cod_produs
    JOIN statie s ON s.cod_statie = a.cod_st
    WHERE s.cod_statie = p_cod_statie
    ORDER BY a.cantitate;
    
    FOR i in 1..v_cant_prod.COUNT LOOP
        dbms_output.put_line('Lista produse: ' || v_cant_prod(i).id_produs || ' ' || v_cant_prod(i).denumire );
    END LOOP;
END;

EXEC p_cant_prod(1001);


-- 2) Def tabel RAPORT, pentru fiecare campanie (cod) - top 3 in fct de nr angajati, statii (cod, denumire, nr angajati) si lista produselor ( cod,denumire) achizitionate
-- adaugati o inregistrare fara null

PRODUS(cod_produs, denumire, pret_vanzare)
COMPANIE(cod, denumire, capital, presedinte)
STATIE(cod_statie, denumire, nr_angajati, cod_companie, capacitate, oras)
ACHIZITIE( cod_st, cod_prod, data_achizitiei, cantitate, pre_achizitie)

SELECT * FROM statie;

SELECT 
    c.cod,
    sum(distinct s.nr_angajati),
    LISTAGG(DISTINCT s.cod_statie || ' ' || s.denumire || ' ' || s.nr_angajati, ', ')
        WITHIN GROUP  (  ORDER BY s.cod_statie, s.denumire, s.nr_angajati ),
    LISTAGG(DISTINCT a.cod_prod || ' ' || p.denumire , ', ')
        WITHIN GROUP ( ORDER BY a.cod_prod, p.denumire )
FROM companie c 
JOIN statie s ON s.cod_companie = c.cod
JOIN achizitie a ON a.cod_st = s.cod_statie
JOIN produs p ON p.cod_produs = a.cod_prod
GROUP BY c.cod
ORDER BY sum(s.nr_angajati) DESC 
FETCH FIRST 3 ROWS WITH TIES


ORDER BY s.nr_angajati DESC
FETCH FIRST 3 ROWS WITH TIES


CREATE TABLE RAPORT( 
    cod_companie NUMBER,
    numar_angajati NUMBER,
    lista_statii VARCHAR2(1000),
    lista_produse VARCHAR2(1000)
);

DROP TABLE RAPORT;
SELECT * FROM PRODUS;

INSERT INTO RAPORT (top_statii, lista_statii, lista_produse)
VALUES('companie 1, companie 2, companie 3','1, Statia 1, 100','101, Benzina 95, 102 Benzina 98');


-- 3) subprogram ca sa populeze RAPORT

CREATE OR REPLACE TYPE o_raport AS OBJECT (
    cod_companie NUMBER,
    numar_angajati NUMBER,
    lista_statii VARCHAR2(1000),
    lista_produse VARCHAR2(1000)
);

CREATE OR REPLACE TYPE t_raport AS TABLE OF o_raport;

DROP TYPE t_raport;

CREATE OR REPLACE PROCEDURE p_raport
IS
    v_raport t_raport := t_raport();
BEGIN
    SELECT o_raport(
        c.cod,
        sum(distinct s.nr_angajati),
        LISTAGG(DISTINCT s.cod_statie || ' ' || s.denumire || ' ' || s.nr_angajati, ', ')
            WITHIN GROUP  (  ORDER BY s.cod_statie, s.denumire, s.nr_angajati ),
        LISTAGG(DISTINCT a.cod_prod || ' ' || p.denumire , ', ')
            WITHIN GROUP ( ORDER BY a.cod_prod, p.denumire )
    )
    BULK COLLECT INTO v_raport
    FROM companie c 
    JOIN statie s ON s.cod_companie = c.cod
    JOIN achizitie a ON a.cod_st = s.cod_statie
    JOIN produs p ON p.cod_produs = a.cod_prod
    GROUP BY c.cod
    ORDER BY sum(s.nr_angajati) DESC 
    FETCH FIRST 3 ROWS WITH TIES;
    
    IF v_raport.COUNT > 0 THEN
        FORALL i in 1..v_raport.COUNT
            INSERT INTO RAPORT(cod_companie,numar_angajati,lista_statii,lista_produse)
            VALUES(v_raport(i).cod_companie, v_raport(i).numar_angajati, v_raport(i).lista_statii, v_raport(i).lista_produse );
    END IF;
END;

EXEC P_RAPORT;



