/*
CREATE TABLE EMPLOYEES(
    employee_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name  VARCHAR(50),
    last_name   VARCHAR(50) NOT NULL,
    email       VARCHAR2(100) UNIQUE,
    hire_date   DATE DEFAULT SYSDATE,
    salary      NUMBER(8,2),
    department_id NUMBER
);

SELECT * FROM EMPLOYEES;
INSERT INTO EMPLOYEES(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY, DEPARTMENT_ID)
VALUES(1, 'John', 'Doe', 'johndoe@email.com', 60000, 100);

INSERT INTO EMPLOYEES(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY, DEPARTMENT_ID)
VALUES(2, 'Jane', 'Doe', 'janedoe@email.com', 65000, 200);

INSERT INTO EMPLOYEES(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY, DEPARTMENT_ID)
VALUES(3, 'John', 'Smith', 'johnsmith@email.com', 75000, 100);

INSERT INTO EMPLOYEES(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY, DEPARTMENT_ID)
VALUES(4, 'Sally', 'Umber', 'sallyumber@email.com', 100000, 102);

INSERT INTO EMPLOYEES(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, SALARY, DEPARTMENT_ID)
VALUES(5, 'Joe', 'South', 'joesouth@email.com', 10000, 300);

INSERT INTO EMPLOYEES(EMPLOYEE_ID,FIRST_NAME,LAST_NAME,EMAIL,SALARY,DEPARTMENT_ID)
VALUES(4,'Daryl','Dyxon','dd@email.com',10000,205);

 1. Creai un bloc PL/SQL care declar 2 variabile (una de tip ir de caractere i cealalt numeric ),
 ini ializate la declarare. Atribuiti valorile acestor variabile PLSQL unor variabile gazd (VARIABLE)
 SQL*Plus i tip riti valorile variabilelor PL/SQL pe ecran. Executai blocul PL/SQL.
 2. Creati si executati un bloc PL/SQL care cere de la tastatura 2 numere (prin variabile de substitutie
 SQL* Plus). Primul numar se va imparti la al doilea, si se va adauga rezultatului cel de-al doilea
 numar. Dac al doilea numr este 0, rezultatul va fi p tratul primului numr (x**2). Rezultatul va fi
 retinut intr-o variabila PL/SQL si va fi tiparit pe ecran.
 3. S se calculeze suma salariilor pentru un job al c rui cod este introdus de utilizator. Cutarea se va
 face case-insensitive.
 4. Creati un bloc PL/SQL care calculeaza castigul total pentru un an, salariul anual si procentul care
 reprezinta bonusul fiind transmise blocului PL/SQL prin variabile de substitutie SQL*Plus. Bonusul
 se va introduce ca numar intreg (pentru bonus de 15% se va introduce 15). Daca salariul este null,
 va fi setat la 0 inainte de a calcula castigul total. Executati blocul PL/SQL. Se va folosi functia NVL
 pentru manipularea valorilor NULL.
 5. Sa se creeze un bloc PL/SQL care calculeaza si modifica valoarea comisionului pentru un angajat al
 carui cod este dat de la tastatura, pe baza salariului acestuia, astfel:- daca salariul este mai mic decat 1000$, comisionul va fi 10% din salariu;- daca salariul ete intre 1000 si 1500$, comisionul va fi 15% din salariu;- daca salariul depaseste 1500$, comisionul va fi 20% din salariu;- daca salariul este NULL, comisionul va fi 0.
 Modific rile se fac în tabelul emp_pnu.
 6. Sa se creeze un bloc PL/SQL care selecteaza codul maxim de departament din tabelul DEPARTMENTS si il stocheaza intr-o variabila SQL*Plus. Se va tipari rezultatul pe ecran.
 7. Sa se creeze un bloc PL/SQL care insereaza un nou departament in tabelul DEPT_PNU. Se va
 folosi parametru de substitutie pentru numele departamentului. Codul este dat de valoarea variabilei
 calculate anterior +1. Locatia va avea valoarea null. Sa se listeze continutul tabelului DEPT_PNU.
 8. Sa se creeze un bloc PL/SQL care reactualizeaza locatia pentru un departament existent (în tabelul
 DEPT_PNU). Se vor folosi parametri de substitutie pentru numarul departamentului si locatia
 acestuia. Sa se listeze codul, numele si locatia pentru departamentul reactualizat.
 9. Sa se creeze un bloc PL/SQL care sterge departamentul creat la exercitiul 7. Se va folosi un
 parametru de substitutie pentru numarul departamentului. Se va tipari pe ecran numarul de linii
 afectate. Ce se intampla daca se introduce un cod de departament care nu exista?

---------------------------------------------------------------------------------------------------

 1. Creai un bloc PL/SQL care declara 2 variabile (una de tip sir de caractere si cealalt numeric ),
 initializate la declarare. Atribuiti valorile acestor variabile PLSQL unor variabile gazda (VARIABLE)
 SQL*Plus si tipariti valorile variabilelor PL/SQL pe ecran. Executati blocul PL/SQL.

*/
-- 1)
SET SERVEROUTPUT ON
DECLARE
    var_sir VARCHAR2(50) := 'Maria Popescu';
    var_num NUMBER       := 4500.75;
BEGIN
    :v_sir := var_sir;
    :v_num := var_num;
    dbms_output.put_line( :v_sir || ' ' || :v_num );
END;
/

-- 2)
/*
    Creati si executati un bloc PL/SQL care cere de la tastatura 2 numere (prin variabile de substitutie
 SQL* Plus). Primul numar se va imparti la al doilea, si se va adauga rezultatului cel de-al doilea
 numar. Daca al doilea numr este 0, rezultatul va fi patratul primului numar (x**2). Rezultatul va fi
 retinut intr-o variabila PL/SQL si va fi tiparit pe ecran. 
*/

DECLARE
    num1 NUMBER := &numar1;
    num2 NUMBER := &numar2;
    rez NUMBER;
BEGIN
    IF num2 = 0 THEN 
        rez := num1**2;
    ELSE
        rez := num1 + num1/num2;
    END IF;
    dbms_output.put_line(rez);
END;

/*
    3. Sa se calculeze suma salariilor pentru un job al carui cod este introdus de utilizator. Cautarea se va face case-insensitive.
*/

DECLARE
    v_cod EMPLOYEES.FIRST_NAME%TYPE := UPPER('&FIRST_NAME');
    v_suma_salariu NUMBER;
BEGIN

    SELECT SUM(SALARY) INTO v_suma_salariu FROM EMPLOYEES WHERE UPPER(FIRST_NAME) = v_cod;    
    dbms_output.put_line(v_suma_salariu);
END;

/*

4. Creati un bloc PL/SQL care calculeaza castigul total pentru un an, salariul anual si procentul care
 reprezinta bonusul fiind transmise blocului PL/SQL prin variabile de substitutie SQL*Plus. Bonusul
 se va introduce ca numar intreg (pentru bonus de 15% se va introduce 15). Daca salariul este null,
 va fi setat la 0 inainte de a calcula castigul total. Executati blocul PL/SQL. Se va folosi functia NVL
 pentru manipularea valorilor NULL.

- transmise prin variabile de substitutie SQL*PLUS  == &variabila

*/

DECLARE
    v_salariu NUMBER := NVL(&salariu, 0);
    v_bonus NUMBER := &bonus;
    v_total NUMBER;
BEGIN
    v_total := v_salariu + (v_salariu * v_bonus / 100);
    dbms_output.put_line(v_total);
END;

/*

5. Sa se creeze un bloc PL/SQL care calculeaza si modifica valoarea comisionului pentru un angajat al
 carui cod este dat de la tastatura, pe baza salariului acestuia, astfel:- daca salariul este mai mic decat 1000$, 
 comisionul va fi 10% din salariu;- daca salariul ete intre 1000 si 1500$, comisionul va fi 15% din salariu
 ;- daca salariul depaseste 1500$, comisionul va fi 20% din salariu;- daca salariul este NULL, comisionul va fi 0.
 Modificarile se fac în tabelul emp_pnu.


ALTER TABLE EMPLOYEES 
ADD (comision NUMBER(8,2));

SELECT * FROM EMPLOYEES;
*/

DECLARE
    v_cod NUMBER := &cod;
    v_comision NUMBER;
    v_salariu NUMBER;
    v_nume employees.FIRST_NAME%TYPE;
    v_last employees.LAST_NAME%TYPE;
BEGIN
    SELECT SALARY INTO v_salariu FROM EMPLOYEES WHERE EMPLOYEE_ID = v_cod;
    IF v_salariu < 1000 THEN 
        v_comision := 10;
    ELSIF v_salariu > 1500 THEN 
        v_comision := 20;
    ELSIF v_salariu <= 1500 AND v_salariu >= 1000 THEN 
        v_comision := 15;
    ELSE
        v_comision := 0;
    END IF;
    SELECT FIRST_NAME INTO v_nume FROM EMPLOYEES WHERE EMPLOYEE_ID = v_cod;
    SELECT LAST_NAME INTO v_last FROM EMPLOYEES WHERE EMPLOYEE_ID = v_cod;
    UPDATE EMPLOYEES SET COMISION = v_comision WHERE EMPLOYEE_ID = v_cod;
    dbms_output.put_line('Comision pentru ' || v_nume || ' ' || v_last || ' este ' || v_comision);
END;

/*
6. Sa se creeze un bloc PL/SQL care selecteaza codul maxim de departament din tabelul DEPARTMENTS si il stocheaza intr-o variabila SQL*Plus. Se va tipari rezultatul pe ecran.
*/

DECLARE
    v_cod employees.department_id%TYPE;
    cod_max employees.department_id%TYPE;
BEGIN
    SELECT max(DEPARTMENT_ID) INTO cod_max FROM EMPLOYEES;
    dbms_output.put_line('Codul maxim de departament este: ' || cod_max);
END;

/*

7.  Sa  se  creeze  un  bloc  PL/SQL  care  insereaza  un  nou  departament  in  tabelul  DEPT_PNU.  Se  va
folosi parametru de substitutie pentru numele departamentului. Codul este dat de valoarea variabilei
calculate anterior +1. Locatia va avea valoarea null. Sa se listeze continutul tabelului DEPT_PNU

- departament nou in tabel ( insert into )
- nume departament var subsitutie
- cod departament = cod_max + 1
- locatie = null
- listarea tabelului DEPT_PNU

*/

CREATE TABLE DEPT_PNU(
  DEPARTMENT_NAME VARCHAR2(30),
  DEPARTMENT_ID NUMBER,
  LOCATION VARCHAR2(200)
);

DECLARE
    v_nume_dept VARCHAR2(50) := '&nume_departament';
    v_cod_max_anterior employees.department_id%TYPE;
    v_cod_max employees.department_id%TYPE;
BEGIN
    SELECT NVL(max(department_id),0)
    INTO v_cod_max_anterior
    FROM employees;
    
    v_cod_max := v_cod_max_anterior + 1;

    INSERT INTO DEPT_PNU(DEPARTMENT_NAME,DEPARTMENT_ID,LOCATION)
    VALUES(v_nume_dept,v_cod_max,null);
END;

SELECT * FROM DEPT_PNU;


/*
8. Sa se creeze un bloc PL/SQL care reactualizeaza locatia pentru un departament existent (în tabelul
DEPT_PNU).  Se  vor  folosi  parametri  de  substitutie  pentru  numarul  departamentului  si  locatia
acestuia. Sa se listeze codul, numele si locatia pentru departamentul reactualizat.
*/

SET SERVEROUTPUT ON
DECLARE
    v_nume_dept dept_pnu.department_name%TYPE;
    v_nr_dept dept_pnu.department_id%TYPE := &numar_departament;
    v_loc_dept dept_pnu.location%TYPE := '&locatie_departament';
BEGIN
    SELECT DEPARTMENT_NAME into v_nume_dept FROM DEPT_PNU WHERE DEPARTMENT_ID = v_nr_dept;
    UPDATE DEPT_PNU SET LOCATION = v_loc_dept WHERE DEPARTMENT_ID = v_nr_dept;
    dbms_output.put_line('Numele departamentului este: ' || v_nume_dept || ' Locatia departamentului este: ' || v_loc_dept || ' Id-ul departamentului este: ' || v_nr_dept );
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        dbms_output.put_line('Departamentul cu ID ' || v_nr_dept || ' nu exista.');
END;

SELECT DEPARTMENT_NAME,DEPARTMENT_ID,LOCATION FROM DEPT_PNU WHERE DEPARTMENT_ID=v_nr_dept;

SELECT * FROM DEPT_PNU;


/*
9.  Sa  se  creeze  un  bloc  PL/SQL  care  sterge  departamentul  creat  la  exercitiul  7.  Se  va  folosi  un
parametru  de  substitutie  pentru  numarul  departamentului.  Se  va  tipari  pe  ecran  numarul  de  linii
afectate. Ce se intampla daca se introduce un cod de departament care nu exista?

- cursor implicit SQL % ROWCOUNT = nr linii incarcate de cursor 
*/

DECLARE
    v_nr_dept dept_pnu.department_id%TYPE := &numar_departament;
BEGIN
    DELETE FROM DEPT_PNU WHERE DEPARTMENT_ID = v_nr_dept;
    IF SQL%ROWCOUNT = 0 THEN
        dbms_output.put_line('Niciun departament nu a fost sters. Codul nu exista.');
    ELSE
        dbms_output.put_line('Departamentul a fost sters. Linii afectate: ' || SQL%ROWCOUNT);
    END IF;
END;

SELECT * FROM DEPT_PNU;
/*
Curs 4 - Tipuri de date
- RECORD
- colectie > tablou indexat
           > tablou imbricat
           > vectori

    RECORD - mecanism pentru prelucrarea inregistrarilor
inregistrarile = campuri cu date diferite dar legate logic
inregistrarile trebuie definite in doi pasi
> se defineste tipul de RECORD
> se declara inregistrarile de acest tip 

OBSERVATII
> un RECORD poate sa aiba un camp de tip RECORD
> mod elegant de a salva o linie returnata de o cerere
> poate constitui un tip de date pentru coloana unui tabel ( varianta stocata )

> compnentele unei inregistrati pot fi de tip scalar, RECORD, TABLE, biect, colectie ( nu REF CURSOR )
> Inregistrarile nu pot fi comparate

ATRIBUTE + METODE COLECTIE
> COUNT - nr componente colectie
> FIRST - indice prim elem tablou
> LAST - indice ultim elem tablou
> EXISTS - intoarce TRUE daca exista in tablou componenta cu indexul specificat
> NEXT - returneaza indicele urmatoarei componente
> PRIOR - returneaza indicele compoentei anterioare
> DELETE - sterge una sau mai multe componente 
> EXTEND - adauga elemente la sfarsit
> LIMIT - numarul maxim de elemente al unei colectii ( de vectori), null pentru tablouri imbricate 
*/


/* RECORD
10.
Să se steargă angajatul având codul 200 din tabelul EMP_PNU. Să se retină într-o variabilă de tip
RECORD  codul,  numele,  salariul  si  departamentul  acestui  angajat  (clauza RETURNING)  .  Să  se
afiseze înregistrarea respectivă. Rollback.
*/

DECLARE
    -- declaram variabila de tip regord
    TYPE info_ang_pnu IS RECORD (
        cod_ang NUMBER(4),
        nume VARCHAR(20),
        salariu NUMBER(8),
        cod_dep NUMBER(4)
    );
    v_info_ang info_ang_pnu;
BEGIN
    DELETE FROM EMP_PNU
    WHERE employee_id = 200
    RETURNING employee_id, last_name, salary, department_id
    INTO v_info_ang;
    
    dbms_output.put_line('A fost stears linia continant valorile ' || v_info_ang.cod_ang || ' ' || v_info_ang.nume || ' ' || v_info_ang.salariu || ' ' || v_info_ang.cod_dep );
END;
/
ROLLBACK;

/*
11.
a) Folosind tipul declarat mai sus, să se adauge o linie în tabelul EMP_PNU prin intermediul unei
variabile de  tip  înregistrare  initializate.  Efectuati modificările necesare  asupra tipului  de date, astfel
încât  această  inserare  să  fie  posibilă.  La  initializarea  unei  variabile  de  tip  record,  tineti  cont  de
constrângerile NOT NULL definite asupra tabelului EMP_PNU.
b)  Modificati  valoarea  unei  componente  a  variabilei  definite  anterior  si  actualizati  continutul  liniei
introduse în tabel.

v_emp emp_pnu%ROWTYPE;
*/

CREATE TABLE emp_pnu (
        cod_ang NUMBER(4),
        nume VARCHAR(20),
        prenume VARCHAR(20),
        email VARCHAR2(50),
        phone_number NUMBER(15), 
        hire_date DATE,
        job_id VARCHAR2(50),
        salariu NUMBER(8,2),
        commision_pct NUMBER,
        manager_id VARCHAR2(50),
        cod_dep NUMBER(4)
);

DROP TABLE EMP_PNU;
SELECT * FROM EMP_PNU;

DECLARE
    TYPE info_ang_pnu IS RECORD (
        cod_ang NUMBER(4) := 500,
        nume VARCHAR(20) := 'abc',
        prenume VARCHAR(20) := 'john',
        email emp_pnu.email%TYPE := 'abc@mail',
        telefon emp_pnu.phone_number%TYPE, 
        data emp_pnu.hire_date%TYPE := SYSDATE,
        job emp_pnu.job_id%TYPE := 'SA_REP',
        salariu NUMBER(8,2) := 1000,
        comision emp_pnu.commision_pct%TYPE,
        manager emp_pnu.manager_id%TYPE,
        cod_dep NUMBER(4) := 30
    );
    v_info_ang_pnu info_ang_pnu;
BEGIN
    -- a) inserare; nu ar fi fost posibila maparea unei variabile tip RECORD intr-o lista
    -- explicita de coloane
    INSERT INTO EMP_PNU
    VALUES v_info_ang_pnu;
    
    dbms_output.put_line('A fost introdusa linia continand valorile ' || v_info_ang_pnu.cod_ang || ' ' || v_info_ang_pnu.nume || ' ' || v_info_ang_pnu.salariu || ' ' || v_info_ang_pnu.cod_dep);
    
    -- b) actualizare
    v_info_ang_pnu.nume := 'golden';
    UPDATE EMP_PNU
    SET ROW = v_info_ang_pnu
    WHERE cod_ang = v_info_ang_pnu.cod_ang;
    
    dbms_output.put_line('A fost actualizata linia cu valorile ....');
END;
/
ROLLBACK;

/*
Analizati si comentati exemplul următor. Afisati valorile variabilelor definite.

DECLARE
  TYPE  tab_index IS TABLE OF NUMBER
    INDEX BY BINARY_INTEGER;
  TYPE  tab_imbri IS TABLE OF NUMBER;
  TYPE  vector IS VARRAY(15) OF NUMBER;
  v_tab_index  tab_index;
  v_tab_imbri  tab_imbri;
  v_vector     vector;
  i INTEGER;
BEGIN
  v_tab_index(1) := 72;
  v_tab_index(2) := 23;
  v_tab_imbri := tab_imbri(5, 3, 2, 8, 7);
  v_vector := vector(1, 2);
-- afisati valorile variabilelor definite; exemplu dat pentru v_tab_imbri
i:=v_tab_imbri.FIRST;
WHILE (i <= v_tab_imbri.LAST) LOOP
  DBMS_OUTPUT.PUT_LINE('v_tab_imbri: '||v_tab_imbri(i));
  i:= v_tab_imbri.NEXT(i);
END LOOP;
END;
/

Loop 1 <= 5  
v_tab_imbri(1) = 5

Loop 2 <=5
v_tab_imbri(2) = 3 

...

5 <= 5
v_tab_imbri(5) = 7



Loop 2 -  

*/

/*

12. Să se definească un tablou indexat PL/SQL având elemente de tipul NUMBER. Să se introducă
20 de elemente în acest tablou. Să se afiseze, apoi să se steargă tabloul utilizând diverse metode.

*/

DECLARE
    TYPE tablou_numar IS TABLE OF NUMBER
        INDEX BY PLS_INTEGER;
    v_tablou tablou_numar;
    v_aux tablou_numar; -- tablou folosit pentru stergere
BEGIN
    FOR i IN 1..20 LOOP
        v_tablou(i) := i;
    DBMS_OUTPUT.PUT_LINE(v_tablou(i));
    END LOOP;
--    FOR i IN v_tablou.FIRST..v_tablou.LAST LOOP -- metoda 1 de stergere
--        v_tablou(i) := NULL;
--    END LOOP;
--    -- SAU
--    v_tablou := v_aux; -- metoda 2 de stergere
--    -- SAU
--    v_tablou.delete; -- metoda 3 de stergere
    DBMS_OUTPUT.PUT_LINE('tabloul are ' || v_tablou.COUNT || ' elemente');
END;
/


/*
13. Să se definească un tablou de înregistrări având tipul celor din tabelul dept_pnu. Să se initializeze
un element al tabloului si să se introducă în tabelul dept_pnu. Să se steargă elementele tabloului
*/

SELECT * FROM employee

DECLARE
    TYPE tablou IS TABLE OF dept_pnu%ROWTYPE
        INDEX BY BINARY_INTEGER;
    dept_table tablou;
    i NUMBER;
BEGIN
    IF dept_table.COUNT <> 0 THEN
        i := dept_table.LAST + 1;
    ELSE i := 1;
    END IF;
    dept_table(i).department_id := 92;
    dept_table(i).department_name := 'NewDep';
    dept_table(i).location_id := 2700;
    
    -- VARIANTA 1 insert
    INSERT INTO dept_pnu( department_id, department_name, location_id)
    VALUES(dept_table(i).department_id,dept_table(i).department_name,dept_table(i).location_id);
    
    -- VARIANTA 2 insert ( Oracle9i )
    INSERT INTO dept_pnu
    VALUES dept_table(i);
    
    dept_table.delete; -- sterge datele din dept_table
    
    dbms_output.put_line('Dupa aplicarea metodei DELETE sunt ' || TO_CHAR(dept_table.COUNT) || ' elemente ' );
END;

/*
VECTORI - varray

- fiecare element are un index - limita inferioara = 1 

6. Analizati si comentati exemplul următor.

DECLARE
    TYPE secventa IS VARRAY(5) OF VARCHAR2(10);
     v_sec  secventa := secventa ('alb', 'negru', 'rosu',
                               'verde');
BEGIN
  v_sec (3) := 'rosu';
  v_sec.EXTEND; -- adauga un element null
  v_sec(5) := 'albastru';
  -- extinderea la 6 elemente va genera eroarea ORA-06532
  v_sec.EXTEND;
END;
/

*/

/*
14.    a) Să se declare un tip proiect_pnu care poate retine maxim 50 de valori de tip VARCHAR2(15).
       b)  Să  se  creeze  un  tabel test_pnu  având  o  coloana cod_ang  de  tip  NUMBER(4)  úi  o  coloană
proiecte_alocate de tip proiect_pnu. Ce relaĠie se modelează în acest fel?
       c)  Să  se  creeze  un  bloc  PL/SQL  care  declară  o  variabilă  (un  vector)  de  tip proiect_pnu,
introduce  valori  în  aceasta  iar  apoi  valoarea  vectorului  respectiv  este  introdusă  pe  una  din  liniile
tabelului test_pnu.
*/

CREATE TYPE proiect_pnu AS VARRAY(50) OF VARCHAR2(15)
CREATE TABLE test_pnu(cod_ang NUMBER(4), proiecte_alocate proiect_pnu);


DECLARE
    v_proiect proiect_pnu := proiect_pnu(); -- initializare utilizand constructorul
BEGIN
    v_proiect.extend(2);
    v_proiect(1) := 'proiect 1';
    v_proiect(2) := 'proiect 2');
    INSERT INTO test_pnu VALUES(1, v_proiect);
END;
/


/*
15.  Să  se  scrie  un  bloc  care  măreste  salariile  angajatilor  din  departamentul  50  cu  10%,  în  cazul  în
care salariul este mai mic decât 5000. Se va utiliza un vector corespunzător codurilor angajatilor. Se cer 3 solutii.
*/

-- Solutia 1 
DECLARE
    TYPE t_id is VARRAY(100) OF emp_pnu.employee_id%TYPE;
    v_id t_id := t_id();
BEGIN
    FOR contor IN (SELECT * FROM emp_pnu) LOOP
    IF contor.DEPARTMENT_id = 50 AND contor.salary < 5000 THEN
        v_id.extend;
        v_id(v_id.COUNT) := contor.employee_id;
    END IF;
    END LOOP;
    FOR contor IN 1..v_id.COUNT LOOP
        UPDATE emp_pnu
        SET salary = salary * 1.1
        WHERE employee_id = v_id(contor);
    END LOOP;
END;

-- Solutia 2 ( varianta FORALL )

DECLARE
    TYPE t_id IS VARRAY(100) OF emp_pnu.employee_id%TYPE;
    v_id t_id := t_id();
BEGIN
    FOR contor IN ( SELECT * FROM emp_pnu ) LOOP
        IF contor.department_id = 50 AND contor.salary < 5000 THEN
            v_id.extend;
            v_id(v_id.COUNT) := contor.employee_id;
        END IF;
    END LOOP;
    FORALL contor IN 1..v_id.COUNT
        UPDATE emp_pnu
        SET salary = salary *1.1
        WHERE employee_id = v_id(contor);
END;

-- Solutia 3 ( varianta BULK COLLECT ) 
DECLARE
    TYPE t_id IS VARRAY(100) OF emp_pnu.employee_id%TYPE;
    v_id t_id := t_id();
BEGIN
    SELECT employee_id
    BULK COLLECT INTO v_id
    FROM emp_pnu
    WHERE department_id = 50 AND salary < 5000;
    FORALL contor IN 1..v_id.COUNT
        UPDATE emp_pnu
        SET salary = salary * 1.1
        WHERE employee_id = v_id(contor);
END;


/*
Tablouri imbricate

16.  Să  se  declare  un  tip  tablou  imbricat si  o  variabilă  de  acest  tip. Initializati  variabila  si  afisati
continutul  tabloului, de la primul la ultimul element si invers.
*/

DECLARE
    TYPE CharTab is TABLE OF CHAR(1);
    v_Characters CharTab := CharTab('M','a','d',',','I','','m');
    v_index INTEGER;
BEGIN
    v_index := v_Characters.FIRST;
    WHILE v_index <= v_Characters.LAST LOOP
        DBMS_OUTPUT.PUT(v_Characters(v_index));
        v_index := v_Characters.NEXT(v_index);
    END LOOP;
    DBMS_OUTPUT.NEW_LINE;
    v_index := v_Characters.LAST;
    WHILE v_index >= v_Characters.FIRST LOOP
        DBMS_OUTPUT.PUT(v_Characters(v_index));
        v_index := v_Characters.PRIOR(v_index);
    END LOOP;
        DBMS_OUTPUT.NEW_LINE;
END;
/



DECLARE
    v_employee_number number := 124;
    v_emp_rec retired_emp%ROWTYPE;
BEGIN
    SELECT employee_id, last_name, job_id, manager_id, hire_date, salary, comission_pct, department_id INTO v_emp_rec
    FROM  employees
    WHERE employee_id = v_employee_number;
    INSERT INTO retired_emps VALUES v_emp_rec;
END;



/*
Curs5 - Cursoare

Exemplu:

Incarcarea datelor dintr-un cursor in doua colectii

DECLARE
TYPE ccopera is TABLE OF opera.cod_opera%TYPE;
TYPE ctopera is TABLE OF opera.titlu%TYPE;
cod1 ccopera; titlu1 ctopera;
CURSOR alfa iS SELECT cod_opera, titlu FROM opera WHERE stil = 'impresionism';
BEGIN
OPEN alfa;
FETCH alfa BULK COLLECT into cod1, titlu1;
CLOSE alfa;
END;
*/

DECLARE
    v_angajat employees%ROWTYPE;  -- RECORD %ROWTYPE = contine toate coloanele unui tabel ( 
BEGIN
    SELECT *
    INTO v_angajat
    FROM employees
    WHERE employee_id = 1;
    DBMS_OUTPUT.PUT_LINE('Nume: ' || v_angajat.first_name || ' ' || v_angajat.last_name);
END;


/*
Exercitii

1.1

Să se scrie un bloc PL/SQL care crește comisionul angajaților din departamentul 80 cu 5%, dar numai dacă salariul lor este mai mare de 3000.
Codurile angajaților care îndeplinesc condiția se vor salva într-un VARRAY.
Apoi, salariile acestora se vor actualiza folosind o buclă care parcurge vectorul.

SAVEPOINT test_savepoint;
ROLLBACK TO SAVEPOINT test_savepoint;

SELECT * FROM EMPLOYEES;

UPDATE EMPLOYEES SET comision = 20 WHERE EMPLOYEE_ID = 3 ;

UPDATE EMPLOYEES SET DEPARTMENT_ID = 80 WHERE DEPARTMENT_ID = 100;

1.2
Să se creeze un bloc PL/SQL care definește un RECORD de tipul unei linii din tabela DEPT_PNU, îl inițializează cu valori, 
îl inserează în tabel, apoi afișează valorile componentei department_name și location.

Linie din DEPT_PNU:

DEPARTMENT_NAME DEPARTMENT_ID LOCATION

*/
-- 1.1
DECLARE
    TYPE t_ceva IS VARRAY(50) OF employees.department_id%TYPE;
    v_tabel t_ceva := t_ceva();
    v_com NUMBER;
BEGIN
    FOR contor IN ( SELECT * FROM EMPLOYEES ) LOOP
    IF contor.DEPARTMENT_ID = 80 AND contor.SALARY > 3000 THEN
        v_tabel.extend;
        v_tabel(v_tabel.COUNT) := contor.employee_id;
    END IF;
    END LOOP;
    FOR contor IN 1..v_tabel.COUNT LOOP
        UPDATE employees
        SET comision = comision + (comision * 0.05)
        WHERE employee_id = v_tabel(contor);
    END LOOP; 
END;
SELECT * FROM EMPLOYEES;
ROLLBACK TO SAVEPOINT test_savepoint;

-- 1.2

/*
    TYPE info_ang_pnu IS RECORD (
        cod_ang NUMBER(4),
        nume VARCHAR(20),
        salariu NUMBER(8),
        cod_dep NUMBER(4)
    );
    v_info_ang info_ang_pnu;

*/

SELECT * FROM DEPT_PNU;

DECLARE
    -- RECORD ( se declara ) -- varianta 1 complet - se poate folosi INSERT INTO <TABEL> VALUES <RECORD>
    -- varianta 2 - la INSERT se declara coloanele care se vor updata atat in TABEL cat si in RECORD ( INSERT INTO <TABEL>(coloana1,coloan2.. ) VALUES <RECORD>(coloana1,coloana2.. )
    TYPE r_tabel IS RECORD (
        nume_d dept_pnu.department_name%TYPE := 'SSG',
        id_d dept_pnu.department_id%TYPE := 2,
        loc_d dept_pnu.location%TYPE := 'Michigan'
    );
    v_tabel r_tabel ;
BEGIN
    INSERT INTO DEPT_PNU
    VALUES v_tabel;
    dbms_output.put_line('Numele departamentului este: ' ||  v_tabel.nume_d   || ' Locatia departamentului este: ' || v_tabel.loc_d  );
END;

SELECT * FROM DEPT_PNU;

/*

1.3

Să se creeze un bloc PL/SQL care definește un RECORD de tipul unei linii din tabelul EMP_PNU,
îl inițializează cu valori valide și îl inserează în tabel. Apoi, valoarea câmpului salary se modifică
în acel RECORD, iar rândul din tabel este actualizat cu întregul RECORD folosind SET ROW =.
La final, se afișează noul salariu.

1.4

Să se creeze un bloc PL/SQL care definește un VARRAY ce conține codurile angajaților din departamentul 60
cu salarii sub 2000. Se vor parcurge codurile salvate în vector și se va șterge din tabelul EMPLOYEES fiecare angajat
care are commission_pct NULL. La final, se afișează câți angajați au fost șterși.

*/

SAVEPOINT test_savepoint;
SELECT * FROM EMP_PNU;

SET SERVEROUTPUT ON -- seteare pentru afisarea output-ului ( dbms_output )
DECLARE
    TYPE r_tabel IS RECORD (
           cod emp_pnu.COD_ANG%TYPE := 1,
           nume emp_pnu.NUME%TYPE := 'Marco',
           prenume emp_pnu.PRENUME%TYPE := 'Polo',
           email emp_pnu.EMAIL%TYPE := 'marco@polo.com',
           phone emp_pnu.PHONE_NUMBER%TYPE := 123456789,
           hire emp_pnu.HIRE_DATE%TYPE := TO_DATE('10-11-2025' , 'DD-MM-YYYY'),
           job emp_pnu.JOB_ID%TYPE := 32,
           salariu emp_pnu.SALARIU%TYPE := 1500,
           comision emp_pnu.COMMISION_PCT%TYPE := 10,
           manager emp_pnu.MANAGER_ID%TYPE := 22,
           cod_dep emp_pnu.COD_DEP%TYPE := 80
    );
    v_tabel r_tabel;
BEGIN
    -- insert line into EMP_PNU
    INSERT INTO EMP_PNU
    VALUES v_tabel;
    
    -- SET ROW salary
    v_tabel.salariu := 2000;
    UPDATE EMP_PNU
    SET ROW = v_tabel
    WHERE cod_ang = v_tabel.cod;
    -- afiseaza salary (dbms_output)
    dbms_output.put_line('Noul salariu este: ' || v_tabel.salariu);
END;
/
ROLLBACK TO SAVEPOINT test_savepoint;

DELETE FROM EMP_PNU;


-- 1.4
SELECT * FROM EMP_PNU;

DECLARE
    -- initializare varray cu - cod ang din dep 60, salarii sub 2000
    TYPE t_varray IS VARRAY(50) OF EMP_PNU.cod_ang%TYPE;
    v_tabel t_varray := t_varray();
    v_total_deleted NUMBER := 0;
BEGIN
    -- Se colecteaza codurile angajatilor din dep 60 cu salarii sub 2000
    FOR contor IN (SELECT * FROM emp_pnu) LOOP
    IF contor.cod_dep = 60 AND contor.salariu < 2000 THEN
        v_tabel.extend;
        v_tabel(v_tabel.COUNT) := contor.cod_ang;
    END IF;
    END LOOP;
    
    -- stergere angajat din EMP_PNU unde com_pct = null
    FOR contor IN 1..v_tabel.COUNT LOOP
        DELETE FROM EMP_PNU
        WHERE cod_ang = v_tabel(contor) AND commision_pct IS NULL;
        v_total_deleted := v_total_deleted + SQL%ROWCOUNT;
    END LOOP;
    
--    DELETE FROM EMP_PNU WHERE v_tabel.commision_pct = NULL;
    IF v_total_deleted = 0 THEN
        dbms_output.put_line('Niciun angajat nu a fost sters. Codul nu exista.');
    ELSE
        dbms_output.put_line('Numar linii(angajati stersi):  ' || v_total_deleted );
    END IF;
END;

INSERT INTO EMP_PNU(COD_ANG,NUME,PRENUME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARIU,MANAGER_ID,COD_DEP) 
VALUES(3,'Jenna','Smith','jenna.smith@email.com','0723456789',SYSDATE,22,3000,'43',85);


UPDATE EMP_PNU SET COD_DEP = 60 WHERE COD_ANG = 2;

SELECT * FROM EMP_PNU;
DELETE FROM EMP_PNU WHERE commision_pct = NULL;

/*
1.5
Să se creeze un bloc PL/SQL care definește un RECORD de tipul unei linii din EMP_PNU. ( RECORD = date asemanatoare o linie ) 
În funcție de valoarea salariului (dacă este sub 2500), să i se seteze un comision de 0.1, altfel 0.2. 
Apoi, recordul se inserează în tabel și se afișează salariul și comisionul. ( insereaza => INSERT INTO x VALUES RECORD

IF sal < 2500 - comm 0.1
ELSE 
comm - 02

INSERARE IN TABEL
AFISARE SAL + COMISION

1.6
Să se creeze un bloc PL/SQL care încarcă într-un VARRAY codurile angajaților din EMP_PNU
care nu au manager (manager_id IS NULL).
Apoi, să li se seteze manager_id := 100, iar modificările să fie raportate pe ecran.
*/

SELECT * FROM EMP_PNU;

DECLARE
    -- definirea RECORD
    TYPE r_record IS RECORD(
       cod emp_pnu.cod_ang%TYPE := 6,
       nume emp_pnu.nume%TYPE := 'Someone',
       prenume emp_pnu.prenume%TYPE := 'Someoneelse',
       email emp_pnu.email%TYPE := 'someone@email.com',
       phone emp_pnu.phone_number%TYPE := '214532',
       data emp_pnu.hire_date%TYPE := SYSDATE,
       j_id emp_pnu.job_id%TYPE := 11,
       sal emp_pnu.salariu%TYPE := 5000,
       com emp_pnu.commision_pct%TYPE := 10,
       man emp_pnu.manager_id%TYPE := 31,
       cod_dep emp_pnu.cod_dep%TYPE := 102
    );
    v_record r_record := r_record();
    
--    com_mic  NUMBER := 0.1;
--    com_mare NUMBER := 0.2;
BEGIN 
    -- INSERT in db
    IF v_record.sal < 2500 THEN 
        v_record.com := 0.1;
        
        INSERT INTO EMP_PNU
        VALUES v_record;
    ELSE
        v_record.com := 0.2;
        
        INSERT INTO EMP_PNU
        VALUES v_record;
    END IF;
    dbms_output.put_line( 'Salariul este: ' || v_record.sal || ' Comisionul este: ' || v_record.com );
END;

SELECT * FROM EMP_PNU;
SELECT * FROM EMP_PNU WHERE salariu < 2500;
ROLLBACK TO SAVEPOINT test_savepoint;

UPDATE EMP_PNU SET MANAGER_ID = NULL WHERE COD_ANG = 4;


-- 1.6
-- cod ang EMP_PNU
-- doar cei cu manager_id = NULL
-- le seteaza manager_id = 100 
-- modificari raportate pe ecran 
DECLARE
    -- VARRAY care primeste toate codurile ang din EMP_PNU
    TYPE var_table IS VARRAY(50) OF EMP_PNU.cod_ang%TYPE;
    v_table var_table := var_table();
BEGIN
    -- populare varray cu date
    FOR contor in ( SELECT * FROM EMP_PNU ) LOOP
        IF contor.manager_id IS NULL THEN
            v_table.extend;
            v_table(v_table.COUNT) := contor.cod_ang;
        END IF;
    END LOOP;
    -- inserare date ?
    FORALL contor IN 1..v_table.COUNT
        UPDATE EMP_PNU
        SET MANAGER_ID = 100
        WHERE COD_ANG = v_table(contor);
END;


SELECT * FROM EMP_PNU;
SAVEPOINT test_savepoint;

/*
1.7
Creează un bloc PL/SQL care definește un RECORD de tipul unei linii din EMP_PNU.
Populează-l cu datele angajatului care are cod_ang = &cod_ang.
Dacă salariul este sub 3000, crește-l cu 20%.
Actualizează linia în tabel folosind SET ROW = și afișează noul salariu.

- TYPE r_record IS RECORD();
- cod_ang = de la tastatura 
- salari < 3000 - creste + 20% din sal
- actualizeaza linia cu SET ROW + afiseaza noul salariu

*/

SELECT * FROM EMP_PNU;

SAVEPOINT test_savepoint;
DECLARE
    TYPE r_record is RECORD (
        c emp_pnu.cod_ang%TYPE := &cod_angajat,
        n emp_pnu.nume%TYPE := 'Unnume',
        p emp_pnu.prenume%TYPE := 'Unprenume',
        e emp_pnu.email%TYPE := 'unnume@email.com',
        pn emp_pnu.phone_number%TYPE := '075824032',
        hd emp_pnu.hire_date%TYPE := SYSDATE,
        jd emp_pnu.job_id%TYPE := 31,
        sa emp_pnu.salariu%TYPE := 2500,
        co emp_pnu.commision_pct%TYPE := 10,
        mi emp_pnu.manager_id%TYPE := 2,
        cd emp_pnu.cod_dep%TYPE := 103
    );
    v_record r_record := r_record();
BEGIN

    INSERT INTO EMP_PNU
    VALUES v_record;
    
    IF v_record.sa < 3000 THEN
        v_record.sa := v_record.sa + ( v_record.sa * 0.2 );
    END IF;

    UPDATE EMP_PNU
    SET ROW = v_record
    WHERE cod_ang = v_record.c;
    dbms_output.put_line('Salariu: ' || v_record.sa );
END;

ROLLBACK TO SAVEPOINT test_savepoint;

/*
1.8
Creează un VARRAY cu codurile angajaților din EMP_PNU care au salariul < 1500 și comisionul NULL.
Șterge acești angajați din tabel.
Afișează numărul total al ștergerilor.

*/

SELECT * FROM EMP_PNU;
SAVEPOINT test;
DECLARE
    TYPE t_tabel IS VARRAY(50) OF EMP_PNU.cod_ang%TYPE;
    v_tabel t_tabel := t_tabel();
    v_total_deleted NUMBER := 0;
BEGIN
    FOR contor in ( SELECT * FROM EMP_PNU ) LOOP
        IF contor.commision_pct IS NULL AND contor.salariu < 1500 THEN
            v_tabel.extend;
            v_tabel(v_tabel.COUNT) := contor.cod_ang;
        END IF;
    END LOOP;
    
    FOR contor in 1..v_tabel.COUNT LOOP
        DELETE FROM EMP_PNU WHERE cod_ang = v_tabel(contor);
        v_total_deleted := v_total_deleted + SQL%ROWCOUNT;
    END LOOP;
    dbms_output.put_line('Numarul de linii sterse este: ' || v_total_deleted);
END;

ROLLBACK TO SAVEPOINT test;

/*
1.9
Să se creeze un bloc PL/SQL care încarcă într-un VARRAY codurile angajaților din EMP_PNU
care au salariul între 1000 și 2500 și nu au comision (commision_pct IS NULL).
Pentru fiecare cod din vector:

    dacă salariul este mai mic decât 2000, se crește salariul cu 10% și comisionul devine 0.1

    în caz contrar (salariul ≥ 2000), angajatul este șters din tabel
    La final, se afișează pe ecran câți angajați au fost actualizați și câți șterși.
*/
SELECT * FROM EMP_PNU;
SAVEPOINT test;
DECLARE
    type t_tabel IS VARRAY(50) OF EMP_PNU.cod_ang%TYPE;
    v_tabel t_tabel := t_tabel();
    ang_sters NUMBER := 0;
    ang_actual NUMBER := 0;
    v_sal EMP_PNU.salariu%TYPE;
    v_nume EMP_PNU.nume%TYPE;
    v_com EMP_PNU.commision_pct%TYPE;
BEGIN
    -- Colecteaza toate codurile angajatilor care indeplinesc criteriul de selectie
    FOR contor IN ( SELECT cod_ang,salariu,commision_pct FROM EMP_PNU ) LOOP
        IF contor.salariu > 1000 AND contor.salariu < 2500 AND contor.commision_pct IS NULL THEN
            v_tabel.extend;
            v_tabel(v_tabel.COUNT) := contor.cod_ang;
        END IF;
    END LOOP;
    -- 
    FOR contor in 1..v_tabel.COUNT LOOP
        SELECT salariu,nume,commision_pct INTO v_sal,v_nume,v_com
        FROM EMP_PNU
        WHERE cod_ang = v_tabel(contor);
        
        IF  v_sal < 2000 THEN
            v_sal := v_sal + ( v_sal * 0.1 );
            v_com := 0.1;
            UPDATE EMP_PNU
            SET salariu = v_sal , commision_pct = v_com
            WHERE cod_ang = v_tabel(contor);
            ang_actual := ang_actual + SQL%ROWCOUNT; -- or + 1 instead of SQL%ROWCOUNT
            dbms_output.put_line('Numele angajatului actualizat este: ' || v_nume);
        ELSIF v_sal >= 2000 THEN
            DELETE FROM EMP_PNU WHERE cod_ang = v_tabel(contor);
            ang_sters := ang_sters + SQL%ROWCOUNT;
            dbms_output.put_line('Numele angajatului sters este: ' || v_nume);
        END IF;
    END LOOP;
    dbms_output.put_line('Numarul de angajati actualizati este: ' || ang_actual || ' Numarul de angajati stersi este: ' || ang_sters );
END;
ROLLBACK TO SAVEPOINT test;

/*
1.10
Să se scrie un bloc PL/SQL care definește o variabilă de tip RECORD, având structura unei linii din tabelul EMP_PNU.
Blocul va parcurge angajații din departamentul 90 și, pentru fiecare:
    dacă salariul este NULL, i se setează valoarea 2000;
    dacă salariul este mai mic decât 3000, se mărește cu 15%;
    valorile fiecărui angajat se vor copia în variabila de tip RECORD;
    modificările se vor salva în tabelul EMP_PNU folosind UPDATE ... SET ROW = ...;
    se va afișa numele, salariul nou și codul angajatului procesat.
*/

SELECT * FROM EMP_PNU;
DECLARE
    -- creem recordul
    TYPE r_tabel IS RECORD (
        c emp_pnu.cod_ang%TYPE,
        n emp_pnu.nume%TYPE,
        p emp_pnu.prenume%TYPE,
        e emp_pnu.email%TYPE,
        pn emp_pnu.phone_number%TYPE,
        hd emp_pnu.hire_date%TYPE,
        ji emp_pnu.job_id%TYPE,
        sa emp_pnu.salariu%TYPE,
        cpc emp_pnu.commision_pct%TYPE,
        mid emp_pnu.manager_id%TYPE,
        cd emp_pnu.cod_dep%TYPE
    );
    -- initializam variabila record din record
    v_tabel r_tabel := r_tabel();
BEGIN  
    -- selectom tot din tabel
    FOR contor IN (SELECT * FROM EMP_PNU WHERE cod_dep = 90) LOOP
        -- adaugam toate datele in v_tabel
        v_tabel := contor;
        IF v_tabel.sa IS NULL THEN
            v_tabel.sa := 2000;
            dbms_output.put_line('Update Salariu pentru ' || v_tabel.n || ' ' || v_tabel.sa);
        ELSIF v_tabel.sa < 3000 THEN
            v_tabel.sa := v_tabel.sa + (v_tabel.sa * 0.15);
            dbms_output.put_line('Update Salariu pentru ' || v_tabel.n || ' ' || v_tabel.sa);
        END IF;
        UPDATE EMP_PNU
        SET ROW = v_tabel
        WHERE cod_ang = v_tabel.c;
    END LOOP;
END;

ROLLBACK TO SAVEPOINT test;
SELECT * FROM EMP_PNU;
UPDATE EMP_PNU
SET cod_dep = 90
WHERE cod_ang = 8;

/*
1.11
Să se scrie un bloc PL/SQL care definește o variabilă de tip RECORD cu structura unei linii din tabelul EMP_PNU și un VARRAY care va conține 
codurile angajaților al căror salariu este mai mic de 2500 și au comisionul NULL. 
Blocul va parcurge toți angajații și va încărca în VARRAY codurile celor care îndeplinesc aceste condiții.
Pentru fiecare cod din vector, se vor aduce datele într-o variabilă de tip RECORD. 
Dacă salariul angajatului este sub 2000, se va actualiza salariul cu 10% și comisionul se va seta la 0.1, iar dacă salariul este între 2000 și 2500 inclusiv, angajatul va fi șters din tabel.
Actualizările se vor face folosind UPDATE SET ROW = ..., iar pentru fiecare angajat modificat sau șters, se va afișa un mesaj cu numele și acțiunea efectuată.
*/

SELECT * FROM EMP_PNU;
DECLARE
    TYPE t_record IS RECORD(
       c emp_pnu.cod_ang%TYPE,
       n emp_pnu.nume%TYPE,
       p emp_pnu.prenume%TYPE,
       e emp_pnu.email%TYPE,
       pn emp_pnu.phone_number%TYPE,
       hd emp_pnu.hire_date%TYPE,
       ji emp_pnu.job_id%TYPE,
       sal emp_pnu.salariu%TYPE,
       cpc emp_pnu.commision_pct%TYPE,
       mi emp_pnu.manager_id%TYPE,
       cd emp_pnu.cod_dep%TYPE
    );
    TYPE t_varray IS VARRAY(50) OF EMP_PNU.cod_ang%TYPE;
    v_record t_record := t_record();
    v_varray t_varray := t_varray();
BEGIN
    -- initializare varray cu codurile angajatilor care au sal < 2500 si commision NULL
    FOR contor in (SELECT cod_ang FROM EMP_PNU WHERE salariu < 2500 AND commision_pct IS NULL) LOOP
        v_varray.extend;
        v_varray(v_varray.COUNT) := contor.cod_ang;
    END LOOP;
    -- itereaza prin elementele varrayului si updateaza cu ajutorul recordului
    FOR i in 1..v_varray.COUNT LOOP
--        FOR contor in ( SELECT * FROM EMP_PNU WHERE cod_ang = v_varray(i)) LOOP 
--            v_record := contor;
            SELECT * INTO v_record from EMP_PNU WHERE cod_ang = v_varray(i);
            IF v_record.sal < 2000 THEN
                v_record.sal := v_record.sal + ( v_record.sal * 0.1 );
                v_record.cpc := 0.1;
                UPDATE EMP_PNU
                SET ROW = v_record
                WHERE cod_ang = v_varray(i);
                dbms_output.put_line('Utilizatorului..' || v_record.n || ' i s-a actualizat salariul la.. ' || v_record.sal);
            ELSIF v_record.sal > 2000 AND v_record.sal <= 2500 THEN
                DELETE FROM EMP_PNU WHERE cod_ang = v_varray(i);
                dbms_output.put_line('Utilizatorul..' || v_record.n || ' a fost sters');
            END IF;
--            dbms_output.put_line('Elementul.. ' || i || ' din varray este.. ' || v_varray(i)  );
    END LOOP;
END;

ROLLBACK TO SAVEPOINT test;
SELECT * FROM EMP_PNU;
SELECT * FROM EMP_PNU WHERE salariu < 2500 AND commision_pct IS NULL

/*
1.12
Să se scrie un bloc PL/SQL care definește o variabilă de tip RECORD având structura unei linii din tabelul DEPT_PNU și un VARRAY 
care va conține codurile tuturor departamentelor care nu au locație setată. 
Pentru fiecare cod din acest vector, se va citi linia completă într-o variabilă RECORD, iar în funcție de valoarea codului de departament,
se va actualiza locația: dacă department_id este mai mic decât 50, se va seta 'Bucuresti', iar în caz contrar 'Cluj'. 
Informațiile actualizate se vor scrie înapoi în tabelul DEPT_PNU folosind UPDATE SET ROW = ..., iar pentru fiecare modificare se va afișa numele departamentului și noua locație.
*/

SELECT * FROM DEPT_PNU;
SAVEPOINT test;
DECLARE
    TYPE t_record is RECORD (
            dn dept_pnu.department_name%TYPE,
            di dept_pnu.department_id%TYPE,
            loc dept_pnu.location%TYPE
    );
    v_record t_record := t_record();
    TYPE t_varray is VARRAY(50) OF dept_pnu.department_id%TYPE;
    v_varray t_varray := t_varray();
BEGIN
    -- insereaza codurile departamentelor care au locatia NULL in varray
    FOR contor in ( SELECT department_id FROM DEPT_PNU WHERE location is NULL ) LOOP
         v_varray.extend;
         v_varray(v_varray.COUNT) := contor.department_id;
    END LOOP;
    -- 
    FOR i in 1..v_varray.COUNT LOOP
        SELECT * INTO v_record FROM DEPT_PNU WHERE department_id = v_varray(i);
        IF  v_record.di < 50 THEN
            v_record.loc := 'Bucuresti';
            UPDATE DEPT_PNU
            SET ROW = v_record
            WHERE department_id = v_varray(i);
            dbms_output.put_line('Noua locatie a departamentului.. ' || v_record.dn || ' este.. ' || v_record.loc);
        ELSE
            v_record.loc := 'Cluj';
            UPDATE DEPT_PNU
            SET ROW = v_record
            WHERE department_id = v_varray(i);
            dbms_output.put_line('Noua locatie a departamentului.. ' || v_record.dn || ' este.. ' || v_record.loc);
        END IF;
    END LOOP;
END;

ROLLBACK TO SAVEPOINT test;

/*
CURSOARE
- implicite SQL%ROWCOUNT / COUNT / ISOPEN / NOTFOUND / FOUND
- explicite <nume-cursor>%ATRIBUT

Declarare cursor explicit 
> se face in DECLARE
> CURSOR <nume-cursor> IS <comanda select>   !! FARA INTO
> se deschide in BEGIN cu OPEN <nume-cursor>


Incarcarea datelor dintr-un cursor explicit 
FETCH <nume-cursor> INTO <nume-variabila>

Exemplu de incarcare date dintr-un cursor in 2 colectii

DECLARE
    TYPE ccopera IS TABLE OF opera.cod_opera%TYPE;
    TYPE ctopera IS TABLE OF opera.cod_titlu%TYPE;
    cod1 ccopera; titlu1 ctopera;
    CURSOR alfa IS SELECT cod_opera, titlu FROM opera WHERE stil = 'impresionism';
BEGIN
    OPEN alfa;
    FETCH alfa BULK COLLECT into cod1, titlu1;
    CLOSE alfa;
END;

*/

/*
Pentru toti arti§tii care au opere de arta expuse in muzeu sa se insereze in tabelul
temp informatii referitoare la numele acestora §i anul na§terii.

DECLARE
    v_nume artist.nume%TYPE;
    v_an_nas artist.an_nastere%TYPE;
    CURSOR info IS SELECT DISTINCT nume, an_nastere FROM artist;
BEGIN
    OPEN info;
        LOOP
            FETCH info INTO v_nume, v_an_nas;
            EXIT WHEN info%NOTFOUND;
            INSERT INTO temp
            VALUES(v_nme || TO_CHAR(v_an_nas));
        END LOOP;
    CLOSE info;
    COMMIT;
END;
*/

/*

Insert pentru cursoare

CREATE TABLE OPERA_EXT (
    cod_opera NUMBER PRIMARY KEY,
    titlu VARCHAR2(100),
    stil VARCHAR2(50),
    valoare NUMBER,
    material VARCHAR2(50),
    cod_artist NUMBER,
    cod_sala NUMBER,
    cod_galerie NUMBER,
    data_achizitie DATE
);

-- Ex: populare rapidă
INSERT INTO OPERA_EXT VALUES (1, 'Venus', 'clasicism', 1500, 'piatra', 101, 10, 1, TO_DATE('1885-01-01','YYYY-MM-DD'));
INSERT INTO OPERA_EXT VALUES (2, 'Apolo', 'renastere', 3000, 'panza', 101, 10, 1, TO_DATE('1950-01-01','YYYY-MM-DD'));
INSERT INTO OPERA_EXT VALUES (3, 'Marte', 'modernism', 900, 'piatra', 102, 11, 2, TO_DATE('1800-01-01','YYYY-MM-DD'));

*/

SELECT * FROM OPERA_EXT;

/*
2.1 - cursor explicit simplu

Se cere să se afle numărul total de opere din tabelul opera care au fost realizate înainte de anul 1900 și să se afișeze codul și titlul fiecărei opere. 
Folosește un cursor explicit cu FETCH.
*/

SET SERVEROUTPUT ON;
DECLARE
    -- creem cursorul 'c'
    CURSOR c IS SELECT cod_opera,titlu FROM OPERA_EXT WHERE DATA_ACHIZITIE < TO_DATE('1900','YYYY');
    v_cod OPERA_EXT.cod_opera%TYPE;
    v_tit OPERA_EXT.titlu%TYPE;
BEGIN
    -- deschidem cursorul
    OPEN c;
    LOOP
        FETCH c into v_cod, v_tit;
        EXIT WHEN c%NOTFOUND;
        dbms_output.put_line('Codul operei este: ' || v_cod || ' si titlul operei este ' || v_tit);
    END LOOP;
    CLOSE c;
END;

/*
2.2 - cursor parametrizat
> cod introdus de la tastatura 
> afiseaza titlul si valoarea fiecarei opere 
> la final afiseaza valoarea totala a operelor acelui artist

Scrie un bloc PL/SQL care declară un cursor parametrizat pentru a selecta operele unui artist al cărui cod este introdus de la tastatură. 
Se vor afișa titlul și valoarea fiecărei opere. La final, se va afișa valoarea totală a operelor acelui artist.
*/

SELECT * FROM OPERA_EXT;
ACCEPT cod NUMBER PROMPT 'Introdu codul artistului: '
DECLARE
    v_cod   OPERA_EXT.cod_artist%TYPE := &cod;
    cursor c is select titlu,valoare from opera_ext where cod_artist = v_cod;
    v_titlu OPERA_EXT.titlu%TYPE;
    v_valoare OPERA_EXT.valoare%TYPE;
    v_total NUMBER := 0;
BEGIN
    OPEN c;
    LOOP
        FETCH c INTO v_titlu, v_valoare;
        EXIT WHEN c%NOTFOUND;
        dbms_output.put_line('Titlu: ' || v_titlu || ' valoare: ' || v_valoare);
        v_total := v_total + v_valoare;
    END LOOP;
    CLOSE c;
    dbms_output.put_line('Valoarea totala este: ' || v_total);
END;

/*
2.3 -- cursor explicit
Pentru toate operele realizate din materialul 'piatra' și având valoare sub 2000, dublează valoarea acestora. 
Folosește un cursor explicit cu FOR UPDATE OF valoare NOWAIT și actualizează folosind WHERE CURRENT OF.
*/

SELECT * FROM opera_ext;
SAVEPOINT test;
DECLARE
    CURSOR c IS SELECT cod_opera,valoare from opera_ext WHERE material = 'piatra' AND valoare < 2000 FOR UPDATE OF valoare NOWAIT;
BEGIN
--    OPEN c;
    FOR contor IN c LOOP
    dbms_output.put_line('Opera cu codul ' || contor.cod_opera || ' are valoarea initiala: ' || contor.valoare);
    UPDATE opera_ext
    SET valoare = contor.valoare * 2
    WHERE CURRENT OF c;
    dbms_output.put_line('Valoarea a fost dublata la: ' || (contor.valoare *2));
    END LOOP;
--    CLOSE c;
END;
ROLLBACK to savepoint test;


/*
2.4 - cursor implicit cu subcerere ( FOR ) 
Scrie un bloc care, pentru fiecare galerie din tabelul galerie, afișează numele galeriei și numărul de opere expuse în acea galerie (din tabelul opera), folosind un ciclu FOR cu subcerere.
*/

SELECT * FROM OPERA_EXT;
DECLARE
    v_numar NUMBER;
BEGIN
    FOR contor IN (SELECT cod_galerie,titlu FROM OPERA_EXT) LOOP
        SELECT COUNT(*) INTO v_numar
        FROM opera_ext
        WHERE cod_galerie = contor.cod_galerie;
        dbms_output.put_line('Numele galeriei este: ' || contor.titlu || ' ' || v_numar );
    END LOOP;
END;

/*
2.5 - cursor imbricat
Să se scrie un bloc PL/SQL care afișează toate galeriile distincte din tabelul OPERA_EXT. 
Pentru fiecare galerie se vor afișa sălile distincte în care sunt expuse opere, iar pentru fiecare sală se vor afișa operele expuse. 
Se vor folosi cursoare imbricate (clasice), de tip FOR, pentru parcurgerea ierarhică: galerie → sală → opere.

CREATE TABLE SALA (
    cod_sala NUMBER PRIMARY KEY,
    denumire VARCHAR2(50),
    cod_galerie NUMBER
);

INSERT INTO SALA VALUES (10, 'Sala Sculptura', 1);
INSERT INTO SALA VALUES (11, 'Sala Pictura', 2);
*/

SAVEPOINT test;

SELECT * FROM SALA;
SELECT * FROM OPERA_EXT;
SET SERVEROUTPUT ON;

DECLARE
    CURSOR c_galerii IS
        SELECT DISTINCT cod_galerie FROM OPERA_EXT;

    CURSOR c_sali(p_galerie NUMBER) IS
        SELECT DISTINCT cod_sala FROM OPERA_EXT
        WHERE cod_galerie = p_galerie;

    CURSOR c_opere(p_sala NUMBER) IS
        SELECT titlu FROM OPERA_EXT
        WHERE cod_sala = p_sala;
BEGIN
    FOR galerie IN c_galerii LOOP
        dbms_output.put_line('Galerie: ' || galerie.cod_galerie);

        FOR sala IN c_sali(galerie.cod_galerie) LOOP
            dbms_output.put_line('  Sala: ' || sala.cod_sala);

            FOR opera IN c_opere(sala.cod_sala) LOOP
                dbms_output.put_line('    Opera: ' || opera.titlu);
            END LOOP;
        END LOOP;
    END LOOP;
END;

ROLLBACK TO SAVEPOINT test;

/*
Exercitii generale

1.1
Să se creeze un bloc anonim în care să se afle media salariilor pentru angajaĠii al căror departament
este 50. Se vor folosi variabilele v_media_sal de tipul coloanei salary úi v_dept (de tip NUMBER).
*/

DECLARE
    v_media_sal employees.salary%TYPE;
    v_dept NUMBER := 50;
BEGIN
    SELECT AVG(salary)
    INTO v_media_sal
    FROM employees
    WHERE department_id = v_dept;
    DBMS_OUTPUT.PUT_LINE('Media salariilor este: ' || v_media_sal);
END;

/*
1.2
Să  se  specifice  dacă un  departament  este  mare,  mediu  sau  mic  după  cum  numărul  angajaĠilor  săi
este  mai mare ca  30, cuprins între 10 úi 30  sau mai mic decât  10. Codul departamentului va  fi cerut
utilizatorului.
*/

SELECT * FROM EMPLOYEES;

ACCEPT cod PROMPT 'Ceva';
DECLARE
    v_cod_dep employees.department_id%TYPE := &cod;
    v_numar NUMBER(3) := 0;
BEGIN
    SELECT COUNT(*) INTO v_numar FROM EMPLOYEES WHERE department_id = v_cod_dep;
    IF v_numar < 4 THEN
        dbms_output.put_line('Mic');
    ELSIF v_numar BETWEEN 10 AND 30 THEN
        dbms_output.put_line('Mediu');
    ELSE
        dbms_output.put_line('Mare');
    END IF; 
END;
/

/*
1.3
  Să  se  creeze  un  bloc  anonim  în  care  se  declară  o  variabilă  v_oras  de  tipul  coloanei  city
(locations.city%TYPE).  AtribuiĠi acestei  variabile numele  oraúului  în  care  se  află  departamentul  având
codul 30. AfiúDĠi în cele două moduri descrise anterior
*/

-- varianta 1
DECLARE
   v_oras locations.city%TYPE;
BEGIN
    SELECT nume INTO v_oras FROM departments d, locations l WHERE d.location_id = l.location_id AND dep_id = 30;
    dbms_output.put_line(v_oras);
END;

-- varianta 2
VARIABLE g_oras VARCHAR(20);
BEGIN
    SELECT city
    INTO :g_oras
    FROM departments d, locations l WHERE d.location_id=l.location_id AND department_id=30;
END;

/*
1.4
 StocaĠi  într-o  variabilă  de  substituĠie  p_cod_dep  valoarea  unui  cod  de  departament.  DefiniĠi  úi  o
variabilă  p_com  care  reĠine  un  număr  din  intervalul  [0,  100].  Pentru  angajaĠii  din  departamentul
respectiv  care  nu  au  comision,  să  se  atribuie  valoarea  lui  p_com  câmpului  commission_pct.  AfiúDĠi
numărul  de  linii  afectate  de  această  actualizare.  Dacă  acest  număr  este  0,  să  se  scrie  « Nici  o  linie
actualizata »

*/

SAVEPOINT test;

SELECT * FROM EMP_PNU;

SET SERVER OUTPUT ON;
SET VERIFY OFF;
DEFINE p_cod_dep = 82;
DEFINE p_com = 10;

--ACCEPT PROMPT cod_dep 'Introduceti codul departamentului'
DECLARE
    v_cod_dep emp_pnu.cod_dep%TYPE := &p_cod_dep;
    v_com NUMBER(3);
BEGIN
    -- cu for loop
    FOR contor IN (SELECT cod_ang,commision_pct FROM emp_pnu WHERE cod_dep = v_cod_dep AND commision_pct IS NULL) LOOP
        UPDATE EMP_PNU
        SET commision_pct = &p_com
        WHERE cod_ang = contor.cod_ang;
    END LOOP;
    IF SQL%ROWCOUNT = 0 THEN
        dbms_output.put_line('Nici o linie actualizata');
    ELSE dbms_output.put_line(SQL%ROWCOUNT || ' linii actualizate');
    END IF;
END;


-- fara for loop 
UPDATE emp_pnu
SET commision_pct = &p_com
WHERE department_id = v_cod_dep;

ROLLBACK TO SAVEPOINT test;

SELECT cod_ang FROM emp_pnu WHERE cod_dep = 82 AND commision_pct IS NULL;

/*
1.5 - exercitiu folosind CASE
 În  funcĠie  de  o  valoare  introdusă  de  utilizator,  utilizând  comanda CASE  se  va  afiúa  un  mesaj  prin
care este specificată ziua săptămânii (a cărei abreviere este chiar valoarea respectivă). UtilizaĠi cele
2 forme ale comenzii CASE
*/

DEFINE p_zi = C

DECLARE
    v_zi CHAR(2) := UPPER('&p_zi');
    v_comentariu VARCHAR(20);
BEGIN
    -- VARIANTA 1 variabila declarata in CASE
    CASE v_zi
        WHEN 'L' THEN v_comentariu := 'Luni';
        WHEN 'M' THEN v_comentariu := 'Marti';
        WHEN 'MI' THEN v_comentariu := 'Miercuri';
        WHEN 'J' THEN v_comentariu := 'Joi';
        WHEN 'V' THEN v_comentariu := 'Vineri';
        WHEN 'S' THEN v_comentariu := 'Sambata';
        WHEN 'D' THEN v_comentariu := 'Duminica';
        ELSE v_comentariu := 'eroare';
    END CASE;
    dbms_output.put_line('Ziua este ' || v_comentariu);
    
    -- VARIANTA 2 variabila declarata in WHEN
    CASE
        WHEN v_zi = 'L' THEN v_comentariu := 'Luni';
        WHEN
        WHEN
        ...
    END case;
END;

/*
1.6

CreaĠi  structura  tabelului org_tab_pnu  constând  din  două  coloane, cod_tab  de  tip INTEGER  ce
conĠine  un  contor  al  înregistrărilor  úi text_tab de tip VARCHAR2  ce  conĠine  un  text  asociat  fiecărei
înregistrări. Să se introducă 70 de înregistrări în acest tabel. Se cer 2 metode.
*/


CREATE TABLE org_tab_pnu (cod_tab NUMBER, text_tab VARCHAR2(50));
INSERT INTO org_tab_pnu (cod_tab,text_tab)
VALUES ();

SELECT * FROM org_tab_pnu;

DEFINE p_text org_tab_pnu.text_tab%TYPE := 'Acesta este un text pentru inregistrarea numarul ';
DEFINE p_cod org_tab_pnu.cod_tab%TYPE;

DECLARE
    v_text_nou org_tab_pnu.text_tab%TYPE;
    v_text org_tab_pnu.text_tab%TYPE := 'Text pentru inregistrarea cu numarul ';
    v_cod org_tab_pnu.cod_tab%TYPE;
    v_count NUMBER := 0;
BEGIN
    FOR i IN 0..69 LOOP
        v_cod := i + 1;
        v_text_nou := v_text || ' ' || TO_CHAR(i+1);
        v_count := i + 1;
        INSERT INTO org_tab_pnu(cod_tab,text_tab)
        VALUES(v_cod,v_text_nou);
    END LOOP;
    dbms_output.put_line(v_count || ' linii introduse');
END;

DELETE FROM org_tab_pnu;

/*
1.7
ScrieĠi un bloc PL/SQL care actualizează conĠinutul tabelului anterior, indicând pe coloana text_tab
dacă numărul cod_tab este par sau impar
*/

SAVEPOINT test;
SELECT * FROM org_tab_pnu;

BEGIN
    FOR contor in (SELECT cod_tab FROM org_tab_pnu) LOOP
        IF MOD(contor.cod_tab, 2) = 0 THEN
            UPDATE org_tab_pnu
            SET text_tab = 'Even'
            WHERE cod_tab = contor.cod_tab;
        ELSE
            UPDATE org_tab_pnu
            SET text_tab = 'Odd'
            WHERE cod_tab = contor.cod_tab;
        END IF;
    END LOOP;
END;

ROLLBACK TO SAVEPOINT test; 

/*
1.8
n structura tabelului emp_pnu se va introduce un nou câmp (stea de tip VARCHAR2(200)). Să se
creeze un bloc PL/SQL care va reactualiza acest câmp, introducând o steluĠă pentru fiecare 100$ din
salariul unui angajat al cărui cod este specificat de către utilizator
*/

SELECT * FROM emp_pnu;

-- adauga coloana stea
ALTER TABLE emp_pnu
ADD (stea VARCHAR2(200));

-- prompt
ACCEPT PROMPT cod_introdus 'Introduceti codul angajatului';
DECLARE
    v_cod emp_pnu.cod_ang%TYPE := &cod_introdus;
    v_stelute emp_pnu.stea%TYPE := '';
    v_contor NUMBER := 0;
    v_salary emp_pnu.salariu%TYPE;
BEGIN
    SELECT salariu INTO v_salary FROM EMP_PNU WHERE cod_ang = v_cod; 
    v_contor := v_salary / 100;
    dbms_output.put_line(v_contor);
    FOR i IN 0..v_contor - 1 LOOP
        v_stelute := v_stelute || '*';
    END LOOP;
    dbms_output.put_line(v_stelute);
    UPDATE emp_pnu
    SET stea = v_stelute
    WHERE cod_ang = v_cod;
END;


INSERT INTO EMP_PNU(COD_ANG,NUME,PRENUME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARIU,MANAGER_ID,COD_DEP) 
VALUES(1,'John','Smith','john.smith@email.com','072345244',SYSDATE,101,10000,'1',100);

INSERT INTO EMP_PNU(COD_ANG,NUME,PRENUME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARIU,MANAGER_ID,COD_DEP) 
VALUES(2,'Randy','Orton','randy.orton@email.com','0723442789',SYSDATE,22,1500,'47',100);

INSERT INTO EMP_PNU(COD_ANG,NUME,PRENUME,EMAIL,PHONE_NUMBER,HIRE_DATE,JOB_ID,SALARIU,MANAGER_ID,COD_DEP) 
VALUES(4,'Jenna','Ortega','jenna.ortega@email.com','0723456789',SYSDATE,25,2000,'1',21);

-- CAP 6 - SUBPROGRAME

/*
Exercițiul 1 – Procedură cu parametru IN și IF-ELSE

Cerință:
Să se scrie o procedură care primește ca parametru codul unui angajat și afișează salariul acestuia. 
Dacă salariul este sub 2000, se va afișa „Mic”, între 2000 și 4000 inclusiv „Mediu”, iar peste 4000 „Mare”.

SET SERVEROUTPUT ON -- seteare pentru afisarea output-ului ( dbms_output )
*/

SELECT * FROM EMP_PNU;
CREATE OR REPLACE PROCEDURE afisare_salariu (
    p_cod_ang IN EMP_PNU.cod_ang%TYPE
) IS
    v_salariu EMP_PNU.salariu%TYPE;
BEGIN
    SELECT salariu INTO v_salariu FROM EMP_PNU WHERE cod_ang = p_cod_ang;
    
    IF v_salariu < 2000 THEN
        DBMS_OUTPUT.PUT_LINE('Mic');
    ELSIF v_salariu <= 4000 THEN
        DBMS_OUTPUT.PUT_LINE('Mediu');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Mare');
    END IF;
END;

EXECUTE afisare_salariu(1);

/* TIPURI DE EXERCITII
1. Bloc PL/SQL cu variabile declarate + user input
2. Bloc PL/SQL cu records (RECORD)
3. Bloc PL/SQL cu varrays (VARRAY)
4. Bloc PL/SQL cu cursoare implicite/explicite (is CURSOR)
5. Supbrograme (PROCEDURE, FUNCTION)
6. Pachete 
7. Triggeri
*/

/*
Exercițiul 2 – Funcție care returnează o valoare

Cerință:
Scrie o funcție care primește codul unui departament și returnează numărul de angajați din acel departament.
*/

SELECT * FROM EMP_PNU;
CREATE OR REPLACE FUNCTION nr_angajati (
    p_cod_dep In EMP_PNU.cod_dep%TYPE
) RETURN NUMBER IS
    v_nr NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO v_nr FROM EMP_PNU WHERE cod_dep = p_cod_dep;
    RETURN v_nr;
END;

-- apelare directa a functiei in SELECT ( from dual tabel fictiv ) 
SELECT nr_angajati(100) FROM dual;

-- apelare intr-un bloc PL/SQL a functiei
DECLARE
    v_nr NUMBER;
BEGIN
    v_nr := nr_angajati(100);
    dbms_output.put_line('Numar angajati: ' || v_nr);
END;

/*


*/