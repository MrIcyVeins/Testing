--CREATE TABLE employees (
--  employee_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--  first_name    VARCHAR2(50),
--  last_name     VARCHAR2(50) NOT NULL,
--  email         VARCHAR2(100) UNIQUE,
--  hire_date     DATE DEFAULT SYSDATE,
--  salary        NUMBER(8, 2),
--  department_id NUMBER
--);

--SELECT * FROM employees;

--INSERT INTO EMPLOYEES TABLE
--INSERT INTO employees (FIRST_NAME, LAST_NAME, EMAIL, SALARY, DEPARTMENT_ID)
--VALUES ('John','Doe','john.doe@email.com','60000.00','100');
--INSERT INTO employees (FIRST_NAME, LAST_NAME, EMAIL, SALARY, DEPARTMENT_ID)
--VALUES ('Jane','Smith','jane.smith@email.com','70000.00','101');


-- dbms_output.put_line needs to be enabled in order to work
--DECLARE
--    message varchar2(20) := 'Hello, World!';
--BEGIN
--    dbms_output.put_line(message);
--END;

-- show all data types
--SELECT DISTINCT data_type
--FROM all_tab_columns
--ORDER BY data_type;

-- DECLARE > BEGIN > END ( variables )
DECLARE 
    a integer  := 10;
    b integer  := 20;
    c integer;
    f integer;
BEGIN
    c := a + b;
    dbms_output.put_line('Value: ' || c);
    f := 70.0/3.0;
    dbms_output.put_line('Value of f: ' || f);
END;
    


-- global vs inner variables 

DECLARE
    num1 number := 95;
    num2 number := 85;
BEGIN
    dbms_output.put_line('Outer Variable num1: ' || num1);
    dbms_output.put_line('Outer Variable num2: ' || num2);
    DECLARE
        num1 number := 195;
        num2 number := 185;
    BEGIN
        dbms_output.put_line('Inner Variable num1: ' || num1);
        dbms_output.put_line('Inner Variable num2: ' || num2);
    END;
    dbms_output.put_line('Test final variable values: ' || num1 || ' ' || num2);
END;

-- 

--CREATE TABLE CUSTOMERS(
--    ID INT NOT NULL,
--    NAME VARCHAR (20) NOT NULL,
--    AGE INT NOT NULL,
--    ADDRESS CHAR (25),
--    SALARY DECIMAL (18,2),
--    PRIMARY KEY (ID)
--);

--INSERT INTO CUSTOMERS (ID, NAME, AGE, ADDRESS, SALARY) 
--VALUES (1, 'Ramesh', 32, 'Ahmedabad', 2000.00);
--
--INSERT INTO CUSTOMERS (ID, NAME, AGE, ADDRESS, SALARY) 
--VALUES (2, 'Khilan', 25, 'Ahmedabad', 1500.00);
--
--INSERT INTO CUSTOMERS (ID, NAME, AGE, ADDRESS, SALARY) 
--VALUES (3, 'kaushik', 23, 'Kota', 2000.00);
--
--INSERT INTO CUSTOMERS (ID, NAME, AGE, ADDRESS, SALARY) 
--VALUES (4, 'Chaitali', 25, 'Mumbai', 6500.00);
--
--INSERT INTO CUSTOMERS (ID, NAME, AGE, ADDRESS, SALARY) 
--VALUES (5, 'Hardik', 27, 'Bhopal', 8500.00);
--
--INSERT INTO CUSTOMERS (ID, NAME, AGE, ADDRESS, SALARY) 
--VALUES (6, 'Komal', 22, 'MP', 4500.00);

DECLARE
    c_id customers.id%type := 5;
    c_name customers.name%type;
    c_addr customers.address%type;
    c_sal customers.salary%type;
BEGIN
    SELECT name, address, salary INTO c_name, c_addr, c_sal
    FROM CUSTOMERS
    WHERE id = c_id;
    dbms_output.put_line
    ('Customer ' || c_name || ' from ' || c_addr || ' earns ' || c_sal);
END;


-- declaring a constant ( needs to be declared before PI/SQL querry ) 

PI CONSTANT NUMBER := 3.14
DECLARE
--    pi constant number := 3.14;
    radius number(5,2);
    dia number(5,2);
    circumference number(7,2);
    area number(10,2);
BEGIN
    radius := 9.5;
    dia := radius * 2;
    circumference := 2.0 * pi * radius;
    area := pi * radius * radius;
    dbms_output.put_line('Radius: ' || radius);
    dbms_output.put_line('Diameter: ' || dia);
    dbms_output.put_line('Circumference: ' || circumference);
    dbms_output.put_line('Area: ' || area);
END;

-- string literal embed single quotes
--DECLARE
--    message varchar2(20) := 'That''s tutorial!';
--BEGIN
--    dbms_output.put_line(message);
--END;

DECLARE
    x number := 10;
BEGIN
    LOOP
        dbms_output.put_line(x);
        x := x + 10;
        IF x > 50 THEN
            exit;
        END IF;
    END LOOP;
    dbms_output.put_line('After Exit x is: ' || x);
END;


SELECT LAST_NAME, EMAIL 
FROM EMPLOYEES;

-- STRUCTURA blocului PL/SQL

DECLARE ( optional )
    - variabile, cursoare, exceptii, tipuri de date locale
BEGIN ( mandatory )
    Comenzi SQL
    Sintaxa PL/SQL
EXCEPTION ( optional )
    Ce actiuni sa interprinda cand are loc o exceptie
END; ( mandatory ) 

-- Tipuri de blocuri PL/SQL
-- Anonymous ( DECLARE -> BEGIN -> EXCEPTION -> END; )
-- - acceste blocuri nu primesc nume, nu sunt stocate

-- Procedure ( PROCEDURE name IS -> BEGIN -> EXCEPTION -> END; )
-- - blocuri care primesc nume, sunt stocate

-- Function ( FUNCTION name -> RETURN datatype IS -> BEGIN  - RETURN value; -> EXCEPTION -> END; )
-- - blocuri care primesc nume, sunt stocate, TREBUIE SA RETURNEZE

SET SERVEROUTPUT ON

SELECT * FROM EMPLOYEES;

DECLARE
    cod_angajat employees.employee_id%TYPE;
    nume_angajat employees.first_name%TYPE;
BEGIN
    cod_angajat := &cod_angajat;
    SELECT FIRST_NAME
    INTO nume_angajat
    FROM employees
    WHERE employee_id = cod_angajat;
    dbms_output.put_line('Numele angajatului este: ' || nume_angajat);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        dbms_output.put_line('Angajatul nu a fost gasit');
    WHEN OTHERS THEN
        dbms_output.put_line('A aparut o eroare: ' || SQLERRM);
END;

-- Definiti un bloc anonim care citeste de la tastatura un
-- nume de angajat si afiseaza salariul.

SET SERVEROUTPUT ON
DECLARE
    salariu_angajat employees.salary%TYPE;
    nume_angajat    employees.first_name%TYPE;
BEGIN
    nume_angajat := '&nume_angajat';
    SELECT
        salary
    INTO salariu_angajat
    FROM
        employees
    WHERE
        first_name = nume_angajat;

    dbms_output.put_line('Salariul angajatului este: ' || salariu_angajat);
END;

/*

boolean - true, false, null
> folosite cu operatii logice AND si OR 
  
LOB
> Book ( CLOB ) / Photo ( BLOB ) / Movie ( BFile) / NCLOB

Variabile de legatura
- pot fi definite de mediu ( env ) 
- sunt denumite variabile host
- nu sunt variabile globale
- sunt definite in SQLDeveloper cu ajutorul VARIABLE
- si pentru SQL si PL/SQL
- pot fi accesate dupa terminarea blocului PL/SQL in care sunt utilizate
- prefixate de ":"
- afisate in SQL cu PRINT

Variabila de legatura AUTOPRINT

*/
DECLARE
    sal_increase employees.salary%TYPE := 800;
BEGIN
    UPDATE employees
    SET salary = salary - sal_increase
    WHERE department_id = 100;
END;

SELECT * FROM employees;

INSERT INTO EMPLOYEES(FIRST_NAME,LAST_NAME,EMAIL,SALARY,DEPARTMENT_ID)
VALUES('Jane','Doe','jane.doe@email.com',30000,100);

UPDATE EMPLOYEES SET employee_id = 3 WHERE email = 'jane.doe@email.com';

/*
Cursoare = pointere catre o zona privata de memorie
- utilizat pentru controlul/manipularea rezultatului unei cereri
- sunt 2 tipuri de variabile cursor
    > implicite ( definite automat )
    > explicite ( definite de utilizator )

*/





